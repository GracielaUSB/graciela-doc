\chapter{Desarrollo}
\label{capitulo3}
\lhead{Capítulo 3. \emph{Desarrollo}}

El diseño y desarrollo de la extensión al compilador de Graciela fueron llevados
a cabo entre marzo y noviembre del año 2016. Luego de una primera etapa de
revisión del trabajo previo, el proyecto se orientó en cuatro áreas, a saber,
(1) Manejo de apuntadores, (2) Teoría de Conjuntos, (3) Tipos de datos definidos
por el programador, (4) Herramientas para el programador.

Durante el transcurso del proyecto, se escribieron múltiples programas de prueba
con el fin de evaluar los distintos módulos del compilador. Estos programas de
prueba pueden conseguirse en el anexo \textbf{NUMERODEANEXO}.

% El diseño y desarrollo de la extensión al compilador de Graciela fueron llevados
% a cabo en tres etapas, entre marzo y noviembre del año 2016. En la primera
% etapa,
%#  se estudió el estado del compilador elaborado por Araujo y Jiménez,
%#  se evaluaron las recomendaciones que sobre la semántica de este lenguaje hizo el
%# jurado de este primer proyecto,
%  se revisó la bibliografía relacionada con el manejo de tipos definidos por el
% usuario en el contexto de programación formal,
%  se investigó sobre posibles estructuras de datos para implantar tipos que modelen la teoría de conjuntos,
%  se especificó formalmente la sintaxis para las nuevas funcionalidades propuestas
% y
%  se extendieron los analizadores lexicográfico y sintáctico para concordar con
% dicha especificación formal.
%
% En la segunda etapa,
%  se completó la verificación de tipos en presencia de tipos definidos por el
% usuario y tipos que modelan la teoría de conjuntos,
%  se extendió la biblioteca
% externa de Graciela para soportar expresiones de tipos que modelan la teoría de
% conjuntos,
%  se inició la extensión al generador de código intermedio LLVM para producir las
% instrucciones correspondientes a las nuevas funcionalidades y
%  se escribió una colección de programas que ejercitan las capacidades del
% lenguaje, tanto nuevas como originales, a fin de evaluar que el código generado
% fuera correcto.
%
% En la tercera etapa,
%  se culminó la extensión al generador de código intermedio iniciada en la etapa
% anterior,
%  se extendió el manual de usuario para presentar las nuevas funcionalidades del
% lenguaje,
%  se investigaron formas para permitir que usuarios noveles instalen el compilador
% sin mayor dificultad
%  se estudiaron las herramientas necesarias para incorporar facilidades de
% depuración (\emph{debugging}) y análisis de rendimiento (\emph{profiling}) al
% compilador.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% REVISIÓN DEL TRABAJO PREVIO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{section}{-1}
\section{Revisión del trabajo previo}

En la primera etapa de este proyecto, se estudió el estado del compilador
elaborado por Araujo y Jiménez y se evaluaron las recomendaciones que sobre la
semántica de este lenguaje hizo el jurado de este primer proyecto.

Se observó que existían aspectos del compilador que podían ser mejorados, y que
además estas mejoras facilitarían el desarrollo de los objetivos del proyecto,
por lo cual se decidió hacer los cambios que se mencionan en esta sección.

% - Reestructuración de la gramática de los programas en Graciela

\subsection{Recomendaciones del Jurado del proyecto de grado de Araujo y Jiménez}

\subsection{Modularización de la base de código}

La base de código que recibimos, en la forma de un repositorio \emph{git},
consistía de unos veinticinco archivos escritos en \emph{Haskell} organizados en
un solo directorio. No existía entre estos archivos gran separación de
responsabilidades y varios de ellos contenían código para acciones que no
guardaban relación entre ellas. En particular, se encontró que el Árbol
Sintáctico Abstracto (\textsc{ASA}) estaba representado como un solo tipo de
datos con más de cuarenta constructores distintos.

Así, se decidió separar el código fuente del compilador en cuatro áreas:
\begin{itemize}

  \item Estructuras de datos para representar el \textsc{ASA} de un programa
  escrito en Graciela. Almacenado en el directorio \texttt{AST}, por las siglas
  en inglés para \textsc{ASA} (\emph{Abstract Syntax Tree}).

  \item Análisis sintáctico para convertir un archivo de código Graciela en un
  ASA, verificando simultáneamente su corrección. Almacenado en el directorio
  \texttt{Parser}, por el término en inglés para análizador sintáctico.

  \item Generación de código intermedio LLVM para programas escritos
  correctamente en Graciela que ya han sido convertidos en un ASA. Almacenado en el
  directorio \texttt{LLVM}.

  \item Código que se usa en más de una de las áreas anteriores, como la Tabla
  de Símbolos del compilador y las estructuras de datos para la emisión de
  mensajes de error, y el archivo principal del compilador. Almacenado en el
  directorio raíz del código fuente.

\end{itemize}

En cada una de las primeras tres áreas, se separaron a su vez los procedimientos
y estructuras según la parte del lenguaje Graciela que se estuviera tratando.
Así, el archivo \texttt{AST/Expression.hs} contiene las estructuras de datos
para representar únicamente las expresiones del lenguaje Graciela como un
\textsc{ASA}, mientras que \texttt{Parser/Expression.hs} contiene la lógica del
analizador sintáctico para interpretar y verificar la corrección de las
expresiones, y \texttt{LLVM/Expression.hs} contiene las reglas de traducción de
\textsc{ASA} a código intermedio \textsc{LLVM} para expresiones.

\subsection{Recuperación de errores en análisis sintáctico}

También se observó que, enfrentado a archivos Graciela con errores sintácticos,
el compilador producía errores difíciles de interpretar. Si bien no es sencillo
generar mensajes de error y continuar el proceso de análisis sintáctico para
archivos que no pertenecen a la gramática del compilador, esta es una
característica que se espera de cualquier compilador si se desea popularizar su
uso.

Desafortunadamente, la biblioteca de análisis sintáctico con la que había sido
desarrollado el proyecto, \texttt{Parsec}, no está diseñada para ofrecer
recuperación de errores, de modo que cualquier solución que usara esta
biblioteca tendría problemas en este aspecto, o al menos resultaría compleja y
más propensa a defectos de programación.

Así, se investigaron bibliotecas alternativas para análisis sintáctico y se
consiguió \texttt{Megaparsec}. Como se explica en el Marco Tecnológico
\todo{explicar en el Marco Tecnológico}, \texttt{Megaparsec} provee el
combinador \texttt{withRecovery}, que permite agregar recuperación de errores a
un analizador sintáctico de manera sencilla. Este combinador recibe una función
de recuperación y un analizador sintáctico base, y ejecuta la primera cuando
dicho analizador falla. Por ejemplo, para agregar recuperación de errores a las
instrucciones, separadas por punto y coma, se usó código como el siguiente:

\begin{haskellcode}
  withRecovery recover instruction
    where
      recover err = void anyToken `manyTill` match TokSemicolon >> tell err
\end{haskellcode}

Así, con ligeros cambios según el contexto del analizador, fue posible agregar
recuperación de errores al compilador.

Otra ventaja de la biblioteca \texttt{Megaparsec} sobre \texttt{Parsec} es que
el \emph{Monad} provisto por la primera, a diferencia del provisto por la
segunda, puede ser utilizado \emph{dentro} de Transformadores de \emph{Monad}s,
permitiendo acumular distintos efectos en una pila de \emph{Monad}s. La utilidad
de esto quedará más clara en la subsección sobre Cuantificaciones.

Finalmente, por tratarse de una bifurcación (\emph{fork}, en inglés) de la
biblioteca \texttt{Parsec}, la mayoría de sus combinadores son idénticos o muy
similares a los de dicha biblioteca, lo cual permitió que la migración del
código de una biblioteca a la otra fuera muy simple.

\subsection{Consideraciones sobre arreglos}

Durante la revisión del compilador original, se consiguió que, como la mayoría
de los lenguajes de bajo nivel, no se ofrecía verificación de acceso a arreglos
dentro de los límites de los mismos. A pesar de que implantar este tipo de
verificaciones no formara parte de los explícita de los objetivos del proyecto,
se consideró que podría agregarse esta funcionalidad para mejorar la experiencia
del programador novel. También se consideró que sería cómodo para el programador
poder hablar de arreglos multidimensionales en lugar de arreglos de arreglos, y
así recibir errores apropiados, a tiempo de compilación, al usar un arreglo de
\texttt{n} dimensiones con un número de índices distinto de \texttt{n}. Por
ejemplo, intentar compilar el siguiente fragmento de código,

\begin{gracielacode}
  |[ var arr : array [5, 10] of int
  ;  writeln(arr[3])
  ]|
\end{gracielacode}

emitiría un mensaje de error acerca del uso de un índice de dimensión 1 para
leer de un arreglo de 2 dimensiones. En la versión original del compilador, la
situación equivalente produciría un error acerca de intentar imprimir un objeto
de tipo arreglo de entero, que no expresa el verdadero problema del caso.

Para evitarle confusión a los programadores, se eliminó la posibiliad de
declarar arreglos de arreglos, y se emite un error a tiempo de compilación cuando esto se hace, 
sugiriendo en cambio utilizar arreglos multidimensionales.

Para implementar estos cambios, fue necesario cambiar la representación interna
de los arreglos. Originalmente, funcionaban como los arreglos del lenguaje C; es
decir, declarar un arreglo \texttt{x} de tamaño \texttt{tam} de elementos de
tipo \texttt{T}, era equivalente a reservar un espacio en la pila de tamaño
$\texttt{sizeof(T)} * \texttt{tam}$ y asociarle al identificador \texttt{x} el
apuntador al primer elemento. Los arreglos multidimensionales se escribían como
arreglos de arreglos, e internamente ocupaban un espacio contiguo de memoria.
Como se deseaba almacenar los tamaños de los arreglos junto con sus elementos,
se decidió usar una representación interna similar a la de arreglos
conformantes, es decir, una estructura cuya primera entrada es la cantidad de
elementos y cuya segunda entrada es el bloque de memoria donde se almacenan los
elementos.

Específicamente, para arreglos de \texttt{n} dimensiones, se generan estructuras
<<cabecera>> de \texttt{n+1} campos, donde los primeros \texttt{n}, de tipo
entero de 32 bit, corresponden a los tamaños en cada dimensión del arreglo, y el
último corresponde a un apuntador a un espacio de memoria contiguo de tamaño
$\texttt{sizeof(T)} * \prod\limits_{i=1}^\texttt{n} dimensi\acute{o}n_i$, que se
reserva en el mismo tipo de memoria que la <<cabecera>>, es decir, en la pila si
es un arreglo estático, o en la memoria dinámica si se trata de un apuntador a
un arreglo inicializado con la instrucción \texttt{new(*)}.

Cuando todas las dimensiones del arreglo son conocidas a tiempo de compilación,
los tamaños de cada dimensión son almacenados estáticamente en la <<cabecera>> y
se reserva el espacio para los elementos en el tipo de memoria apropiado. Cuando
este no es el caso, se genera el código para, a tiempo de ejecución, evaluar la
expresión correspondiente a cada dimensión del arreglo, almacenar en el campo
correspondiente de la cabecera el valor resultante, y reservar el espacio para
los elementos en el tipo de memoria apropiado.

El hecho de que sean almacenados en dos partes podría causar preocupaciones
respecto a la liberación de memoria ocupada por arreglos dinámicos. Sin embargo,
este caso fue tomado en cuenta y la liberación de memoria procede en dos partes,
liberando primero el bloque de elementos, y posteriormente la <<cabecera>>.

\subsection{Consideraciones sobre funciones y procedimientos}
\blindtext[1]
% - Gramática
% - Cota
% - Cambios en proc (sin : antes de los parámetros)
%     - {pre} y {post} están juntas, {bound} opcional para procedimientos
%       recursivos
%     - se elminó el modo de parámetros "ref", equivalente a in-out -- MONASCAL?
\subsubsection{Generación de código intermedio}
% Cotas de funciones y procedimientos

\subsection{Consideraciones sobre cuantificaciones}
\blindtext[1]
%     - Posibilidad de usar colecciones como rango
%     - Separación del "rango" en "rango" y condiciones

\subsubsection{Generación de código intermedio}
% Cuantificaciones

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% MANEJO DE APUNTADORES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manejo de apuntadores}
  
\subsection{Consideraciones}
Los apuntador se diseñaron para apuntar a un objeto cualquier tipo básico,
arreglo o un tipo definido por el usuario. La sintaxis para declarar un
apuntador es parecida a la que usa el lenguaje C, es decir, se escribe el tipo
base seguido de tantos asteriscos como apuntadores se desee. El operador para
desreferenciar un apuntador es igualmente el asterisco, el cual debe colocarse
como operador prefijo a una variable de tipo apuntador. Se eligió esta
sintaxis para poder introducir al estudiante a los apuntadores del lenguaje C.

La reserva y liberación de memoria dinámica para un apuntador se realiza con las funciones propias del lenguaje \texttt{new} y \texttt{free}, ambas con consideraciones especiales para el caso de apuntadores y estructuras, las cuales se explican en sus secciones respectivas. El siguiente fragmento de codigo ejemplifica la declaración y uso de un apuntador a entero.

\begin{gracielacode}
  |[ var p : int*
  ;  new(p)
  ;  *p := 10
  ;  free(p)
  ]|
\end{gracielacode}

\subsection{Generación de código intermedio}
LLVM ofrece un soporte completo para el manejo de apuntadores, por lo que la generacion de codigo intermedio fue de cierta manera sencilla. Sin embargo, carece de instrucciones para la reserva y liberación de memoria dinámica, Por lo que hubo la necesidad de colocar funciones en la biblioteca externa que reciban como argumento el apuntador en cuestión, y que a su vez llamaran rutinas del lenguaje C que se ocupasen de realizar dichas operaciones.

Para la reserva de memoria dinámica, se utilizó la función standard de C \texttt{kalloc}, la cual reserva la cantidad de memoria que se le da como argumentos e inicializa todos los bytes a 0. Por otro lado, la liberación de memoria dinámica hace llamando a la función standard de C \texttt{free} y luego asignando al apuntador que se esta liberando un valor nulo, de manera de evitar que el programador pueda interactuar con apuntadores a direcciones que no puede acceder. En caso de tratar de liberar un apuntador mas de una vez o si este contiene un valor nulo, se emite un error diciendo el lugar donde se realizó la operación y se aborta el programa, en vez de permitir que sea el sistema operativo quien emita el error.


  % - malloc
  % - free
  % - Apuntadores y estructuras (malloc recibe tamaño en bytes, debe ser calculado: getElementPointer)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TEORÍA DE CONJUNTOS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Teoría de conjuntos}
\subsection{Consideraciones}
\blindtext[1]
% - Similares a cuantificaciones, aplican restricciones similares
% - Notación para relation y function:
%     : relation int <-> char, rel(<conjunto de pares>)
%     : function char -> float, func(<conjunto de pares>)

\subsection{Biblioteca externa para teoría de conjuntos}
\blindtext[1]
% - Backend en C++ (std)

\subsection{Generación de código intermedio}
\blindtext[1]
% Conjuntos

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TIPOS DE DATOS (...) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tipos de datos definidos por el programador}
\blindtext[1]
\subsection{Consideraciones}
%  - breve discusión de Carroll Morgan
%  - LA GRAMÁTICA VA AL FINAL PERO IGUAL HABLAMOS SOBRE ELLA
% ¿Qué es un tipo de dato (abstracto/concreto)?
        % - Consideraciones
        % - Qué significa que un TDC implemente un TDA, relación de refinamiento
        % - Variables de tipo
        % - Invariantes de representación, acoplamiento
        % - Procedimientos y Funciones de/sobre un TAD
\subsection{Generación de código intermedio}
% TDDDPEU
% Variables de tipo
% - Invariantes de representación, acoplamiento
%     - Invariante de acoplamiento "compilable"
% - Procedimientos y Funciones de/sobre un TAD

\subsection{Verificación de tipos}
\blindtext[1]
% - breve discusión de =:= y <> de tipos, también de funciones con argumentos
%   con variables de tipo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% HERRAMIENTAS PARA EL PROGRAMADOR %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Herramientas para el programador}
% \subsection{Colección de programas}
% \blindtext[1]
% % Referencia a los anexos
\subsection{Facilidad de instalación para usuarios noveles}
\blindtext[1]

\subsection{Depuración y análisis de rendimiento}
\blindtext[1]
