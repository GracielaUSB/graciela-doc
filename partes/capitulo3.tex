\chapter{Desarrollo}
\label{capitulo3}
\lhead{Capítulo 3. \emph{Desarrollo}}

El diseño y desarrollo de la extensión al compilador de Graciela fueron llevados
a cabo entre marzo y noviembre del año 2016. Luego de una primera etapa de
revisión del trabajo previo, el proyecto se orientó en cuatro áreas, a saber,
(1) Manejo de apuntadores, (2) Teoría de Conjuntos, (3) Tipos de datos definidos
por el programador, (4) Herramientas para el programador.

Durante el transcurso del proyecto, se escribieron múltiples programas de prueba
con el fin de evaluar los distintos módulos del compilador. Estos programas de
prueba pueden conseguirse en el anexo \textbf{NUMERODEANEXO}.

% El diseño y desarrollo de la extensión al compilador de Graciela fueron llevados
% a cabo en tres etapas, entre marzo y noviembre del año 2016. En la primera
% etapa,
%#  se estudió el estado del compilador elaborado por Araujo y Jiménez,
%#  se evaluaron las recomendaciones que sobre la semántica de este lenguaje hizo el
%# jurado de este primer proyecto,
%  se revisó la bibliografía relacionada con el manejo de tipos definidos por el
% usuario en el contexto de programación formal,
%  se investigó sobre posibles estructuras de datos para implantar tipos que modelen la teoría de conjuntos,
%  se especificó formalmente la sintaxis para las nuevas funcionalidades propuestas
% y
%  se extendieron los analizadores lexicográfico y sintáctico para concordar con
% dicha especificación formal.
%
% En la segunda etapa,
%  se completó la verificación de tipos en presencia de tipos definidos por el
% usuario y tipos que modelan la teoría de conjuntos,
%  se extendió la biblioteca
% externa de Graciela para soportar expresiones de tipos que modelan la teoría de
% conjuntos,
%  se inició la extensión al generador de código intermedio LLVM para producir las
% instrucciones correspondientes a las nuevas funcionalidades y
%  se escribió una colección de programas que ejercitan las capacidades del
% lenguaje, tanto nuevas como originales, a fin de evaluar que el código generado
% fuera correcto.
%
% En la tercera etapa,
%  se culminó la extensión al generador de código intermedio iniciada en la etapa
% anterior,
%  se extendió el manual de usuario para presentar las nuevas funcionalidades del
% lenguaje,
%  se investigaron formas para permitir que usuarios noveles instalen el compilador
% sin mayor dificultad
%  se estudiaron las herramientas necesarias para incorporar facilidades de
% depuración (\emph{debugging}) y análisis de rendimiento (\emph{profiling}) al
% compilador.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% REVISIÓN DEL TRABAJO PREVIO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{section}{-1}
\section{Revisión del trabajo previo}

En la primera etapa de este proyecto, se estudió el estado del compilador
elaborado por Araujo y Jiménez y se evaluaron las recomendaciones que sobre la
semántica de este lenguaje hizo el jurado de este primer proyecto.

Se observó que existían aspectos del compilador que podían ser mejorados, y que
además estas mejoras facilitarían el desarrollo de los objetivos del proyecto,
por lo cual se decidió hacer los cambios que se mencionan en esta sección.

% - Reestructuración de la gramática de los programas en Graciela

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Recomendaciones del Jurado del proyecto de grado de Araujo y Jiménez}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Modularización de la base de código}

La base de código que recibimos, en la forma de un repositorio \emph{git},
consistía de unos veinticinco archivos escritos en \emph{Haskell} organizados en
un solo directorio. No existía entre estos archivos gran separación de
responsabilidades y varios de ellos contenían código para acciones que no
guardaban relación entre ellas. En particular, se encontró que el Árbol
Sintáctico Abstracto (\textsc{ASA}) estaba representado como un solo tipo de
datos con más de cuarenta constructores distintos.

Así, se decidió separar el código fuente del compilador en cuatro áreas:
\begin{itemize}

  \item Estructuras de datos para representar el \textsc{ASA} de un programa
  escrito en Graciela. Almacenado en el directorio \texttt{AST}, por las siglas
  en inglés para \textsc{ASA} (\emph{Abstract Syntax Tree}).

  \item Análisis sintáctico para convertir un archivo de código Graciela en un
  ASA, verificando simultáneamente su corrección. Almacenado en el directorio
  \texttt{Parser}, por el término en inglés para análizador sintáctico.

  \item Generación de código intermedio LLVM para programas escritos
  correctamente en Graciela que ya han sido convertidos en un ASA. Almacenado en el
  directorio \texttt{LLVM}.

  \item Código que se usa en más de una de las áreas anteriores, como la Tabla
  de Símbolos del compilador y las estructuras de datos para la emisión de
  mensajes de error, y el archivo principal del compilador. Almacenado en el
  directorio raíz del código fuente.

\end{itemize}

En cada una de las primeras tres áreas, se separaron a su vez los procedimientos
y estructuras según la parte del lenguaje Graciela que se estuviera tratando.
Así, el archivo \texttt{AST/Expression.hs} contiene las estructuras de datos
para representar únicamente las expresiones del lenguaje Graciela como un
\textsc{ASA}, mientras que \texttt{Parser/Expression.hs} contiene la lógica del
analizador sintáctico para interpretar y verificar la corrección de las
expresiones, y \texttt{LLVM/Expression.hs} contiene las reglas de traducción de
\textsc{ASA} a código intermedio \textsc{LLVM} para expresiones.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Recuperación de errores en análisis sintáctico}

También se observó que, enfrentado a archivos Graciela con errores sintácticos,
el compilador producía errores difíciles de interpretar. Si bien no es sencillo
generar mensajes de error y continuar el proceso de análisis sintáctico para
archivos que no pertenecen a la gramática del compilador, esta es una
característica que se espera de cualquier compilador si se desea popularizar su
uso.

Desafortunadamente, la biblioteca de análisis sintáctico con la que había sido
desarrollado el proyecto, \texttt{Parsec}, no está diseñada para ofrecer
recuperación de errores, de modo que cualquier solución que usara esta
biblioteca tendría problemas en este aspecto, o al menos resultaría compleja y
más propensa a defectos de programación.

Así, se investigaron bibliotecas alternativas para análisis sintáctico y se
consiguió \texttt{Megaparsec}. Como se explica en el Marco Tecnológico
\todo{explicar en el Marco Tecnológico}, \texttt{Megaparsec} provee el
combinador \texttt{withRecovery}, que permite agregar recuperación de errores a
un analizador sintáctico de manera sencilla. Este combinador recibe una función
de recuperación y un analizador sintáctico base, y ejecuta la primera cuando
dicho analizador falla. Por ejemplo, para agregar recuperación de errores a las
instrucciones, separadas por punto y coma, se usó código como el siguiente:

\begin{haskellcode}
  withRecovery recover instruction
    where
      recover err = void anyToken `manyTill` match TokSemicolon >> tell err
\end{haskellcode}

Así, con ligeros cambios según el contexto del analizador, fue posible agregar
recuperación de errores al compilador.

Otra ventaja de la biblioteca \texttt{Megaparsec} sobre \texttt{Parsec} es que
el \emph{Monad} provisto por la primera, a diferencia del provisto por la
segunda, puede ser utilizado \emph{dentro} de Transformadores de \emph{Monad}s,
permitiendo acumular distintos efectos en una pila de \emph{Monad}s. La utilidad
de esto quedará más clara en la subsección sobre Cuantificaciones.

Finalmente, por tratarse de una bifurcación (\emph{fork}, en inglés) de la
biblioteca \texttt{Parsec}, la mayoría de sus combinadores son idénticos o muy
similares a los de dicha biblioteca, lo cual permitió que la migración del
código de una biblioteca a la otra fuera muy simple.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Consideraciones sobre arreglos}

Durante la revisión del compilador original, se consiguió que, como en la
mayoría de los lenguajes de bajo nivel, no se ofrecía verificación de acceso a
arreglos dentro de los límites de los mismos. A pesar de que implantar este tipo
de verificaciones no formara parte explícita de los objetivos del proyecto, se
consideró que podría agregarse esta funcionalidad para mejorar la experiencia
del programador novel. 

También se consideró que sería cómodo para el programador poder hablar de
arreglos multidimensionales en lugar de arreglos de arreglos, y así recibir
errores apropiados, a tiempo de compilación, al usar un arreglo de \texttt{n}
dimensiones con un número de índices distinto de \texttt{n}. Por ejemplo,
intentar compilar el siguiente fragmento de código,

\begin{gracielacode}
  |[ var arr : array [5, 10] of int
  ;  writeln(arr[3])
  ]|
\end{gracielacode}

emitiría un mensaje de error acerca del uso de un índice de dimensión 1 para
leer de un arreglo de 2 dimensiones. En la versión original del compilador, la
situación equivalente produciría un error acerca de intentar imprimir un objeto
de tipo arreglo de entero, que no expresa el verdadero problema del caso.

Para evitarle confusión a los programadores, se eliminó la posibiliad de
declarar arreglos de arreglos, y se emite un error a tiempo de compilación
cuando esto se hace, sugiriendo en cambio utilizar arreglos multidimensionales.

Para implementar estos cambios, fue necesario cambiar la representación interna
de los arreglos. Originalmente, funcionaban como los arreglos del lenguaje C; es
decir, declarar un arreglo \texttt{x} de tamaño \texttt{tam} de elementos de
tipo \texttt{T}, era equivalente a reservar un espacio en la pila de tamaño
$\texttt{sizeof(T)} * \texttt{tam}$ y asociarle al identificador \texttt{x} el
apuntador al primer elemento. Los arreglos multidimensionales se escribían como
arreglos de arreglos, e internamente ocupaban un espacio contiguo de memoria.
Como se deseaba almacenar los tamaños de los arreglos junto con sus elementos,
se decidió usar una representación interna similar a la de arreglos
conformantes, es decir, una estructura cuya primera entrada es la cantidad de
elementos y cuya segunda entrada es el bloque de memoria donde se almacenan los
elementos.

Específicamente, para arreglos de \texttt{n} dimensiones, se generan estructuras
<<cabecera>> de \texttt{n+1} campos, donde los primeros \texttt{n}, de tipo
entero de 32 bit, corresponden a los tamaños en cada dimensión del arreglo, y el
último corresponde a un apuntador a un espacio de memoria contiguo de tamaño
$\texttt{sizeof(T)} * \prod\limits_{i=1}^\texttt{n} dimensi\acute{o}n_i$, que se
reserva en el mismo tipo de memoria que la <<cabecera>>, es decir, en la pila si
es un arreglo estático, o en la memoria dinámica si se trata de un apuntador a
un arreglo inicializado con la instrucción \texttt{new(*)}.

Cuando todas las dimensiones del arreglo son conocidas a tiempo de compilación,
los tamaños de cada dimensión son almacenados estáticamente en la <<cabecera>> y
se reserva el espacio para los elementos en el tipo de memoria apropiado. Cuando
este no es el caso, se genera el código para, a tiempo de ejecución, evaluar la
expresión correspondiente a cada dimensión del arreglo, almacenar en el campo
correspondiente de la cabecera el valor resultante, y reservar el espacio para
los elementos en el tipo de memoria apropiado.

El hecho de que sean almacenados en dos partes podría causar preocupaciones
respecto a la liberación de memoria ocupada por arreglos dinámicos. Sin embargo,
este caso fue tomado en cuenta y la liberación de memoria procede en dos partes,
liberando primero el bloque de elementos, y posteriormente la <<cabecera>>.

La última consideración sobre los arreglos está asociada con su uso como
parámetros de subrutinas (procedimientos y funciones). Se decidió permitir el
pase de arreglos de tamaño variable como parámetros siempre que todas las
variables en las expresiones que denotan su tamaño sean parámetros anteriores de
la subrutina, pasados en modo \texttt{in} (todos los parámetros de las funciones
son pasados en modo \texttt{in}). Por ejemplo, la firma del siguiente
procedimiento sería aceptada por el compilador:

\begin{gracielacode}
  proc sub(in size : int, inout arr : array [size, size * 2] of int)
\end{gracielacode}

Desafortunadamente, un procedimiento (o una función) con una firma similar a la
de \texttt{sub} podría ser llamado con argumentos que no concuerden, por
ejemplo,

\begin{gracielacode}
  |[ var arr : array [5, 5]
  ;  sub (5, arr)
  ]|
\end{gracielacode}

En este caso, el procedimiento \texttt{sub} espera un arreglo rectangular de
tamaño \texttt{[size, (size * 2)]}, y como recibe \texttt{size = 5}, espera que
el tamaño del arreglo sea \texttt{[5, 10]}. Sin embargo, recibe un arreglo de
tamaño \texttt{[5, 5]}, por lo cual la ejecución debe abortar al momento de esa
llamada. Esta verificación no puede hacerse a tiempo de compilación en el caso
general, puesto que sería necesario \todo{consultar esto con Monascal}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Consideraciones sobre funciones y procedimientos}

Se decidió cambiar ligeramente la gramática de las funciones y procedimientos
para que fueran más similaras a sus equivalentes en GCL. Simplemente, se
eliminaron los lexemas \texttt{begin} y \texttt{end}, antes usados para
delimitar el procedimiento, y el lexema \texttt{:} entre el identificador de la
subrutina y su lista de parámetros, y se movió la poscondición junto a la
precondición, antes del cuerpo de la subrutina.

Además, se agregó la posibilidad de especificar cotas para las subrutinas luego
de la poscondición y antes del cuerpo, como requisito para hacer llamadas
recursivas dentro de la misma. Así, es un error a tiempo de compilación escribir
una llamada recursiva de una subrutina sin cota. En el caso contrario, el de una
subrutina con cota pero sin recursión, ésta simplemente es ignorada. A pesar de
que esto no estaba dentro de los objetivos de este proyecto, se consideró de
suma importancia, puesto que la recursión sin cotas es equivalente a la
iteración sin cotas, prohibida en el caso de la instrucción \texttt{do .. od}.

El código intermedio LLVM generado para una subrutina recursiva, necesariamente
con cota, además de incluir el cuerpo especificado por el programador, incluye
verificaciones para el decrecimiento y la no-negatividad de la cota. Esto se
logra pasando dos parámetros adicionales a las subrutinas recursivas. El
primero, de tipo booleano, indica si la llamada en curso es la primera llamada a
la subrutina o si se trata de una llamada recursiva. En ambos casos, al entrar a
la subrutina se calcula el valor de la cota, y si es negativa se da un error y
el programa aborta. En caso contrario, si se trata de la primera llamada a la
subrutina, se ejecuta el cuerpo de ésta, pero si se trata de una llamada
recursiva, se compara la cota actual con la anterior, recibida como el segundo
parámetro implícito. Si no hubo decremento en la cota, también se da un error y
el programa aborta. En caso contrario, se ejecuta el cuerpo de la subrutina.

Por último, cabe mencionar que se eliminó el modo de parámetros
<<\texttt{ref}>>, puesto que resulta equivalente al modo <<\texttt{inout}>>
\todo{Consultar con Monascal.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Consideraciones sobre cuantificaciones}

Durante el análisis del compilador original, se conoció que las cuantificaciones
presentaban limitaciones en la expresividad de sus rangos. El analizador
sintáctico de esta parte del lenguaje esperaba, específicamente, dos
comparaciones aritméticas, separadas por un operador de conjunción
(\texttt{/\\}), seguidas por un lexema <<barra vertical>> (\texttt{|}). Esto
impedía expresar condiciones lógicas distintas de comparaciones aritméticas,
como predicados definidos por el programador, o incluso condiciones con más de
dos comparaciones aritméticas.

Para solucionar esto, se agregó un estado al analizador sintáctico de las
expresiones, usando el \emph{Monad Transformer} \texttt{StateT} sobre el
\emph{Monad} \texttt{Parsec}. En este estado, se guarda información sobre la
pila de variables \emph{dummy} presentes en un momento dado (la pila vacía en el
caso de las expresiones sin cuantificaciones). Además, se permitió que el
analizador sintáctico de las expresiones devolviera, además de la expresión
conseguida, el rango asociado a ella. Por ejemplo, con la variable \emph{dummy}
\texttt{x}, la expresión \texttt{x >= 5} tiene asociado el rango $[5, \infty)$.

Cuando el analizador sintáctico se encuentra en una cuantificación, agrega la
variable \emph{dummy} correspondiente a la pila del estado, e intenta construir
un rango. Los únicos operadores que construyen rangos son la igualdad
(\texttt{==}), que construye rangos <<unitarios>>; las comparaciones aritméticas
(\texttt{>}, \texttt{>=}, \texttt{<}, \texttt{<=}), que construyen rangos
<<aritméticos>>; y el operador <<pertenece>> de la teoría de conjuntos ($\in$)
\todo{los conjuntos y demás tipos de la teoría de conjuntos se explican más
adelante, ¿cómo decir eso?}, que produce rangos <<conjunto>>, mientras que la
constante booleana \texttt{false} produce el rango <<vacío>>. 

Además, el operador de conjunción (\texttt{/\\}) devuelve, si es posible, el
rango que resulta de intersectar los rangos asociados a cada uno de sus
operandos. A diferencia de las cuantificaciones lógicas, sin embargo, no se
consideran los rangos generados por el operador de disjunción (\texttt{\\/}),
por lo cual si se desea que un rango sea procesado como tal, debe estar escrito
en Forma Normal Conjuntiva. Esto no le resta expresividad al lenguaje, ya que
pueden conseguirse expresiones equivalentes con el uso de teoremas lógicos,
convirtiendo una cuantificación en la disjunción de varias, o usando el operador
de unión de conjuntos ($\cup$).

Finalmente, si se ha construido un rango válido, este se registra en
el ASA correspondiente a la cuantificación. Si el rango es <<aritmético>>, se
exige que existan límites superior e inferior, emitiéndose el error apropiado en
caso de faltar uno de los límites. Cabe mencionar que si la variable
\texttt{dummy} es de tipo número de punto flotante, las comparaciones
aritméticas \emph{no} generarán rangos, puesto que es imposible iterar sobre
números de este tipo. 

El código intermedio LLVM generado para cada cuantificación dependerá de la
clase del rango sobre el cual esté definida:

\begin{description}

  \item [Rango <<vacío>>] se genera el valor neutro del cuantificador, o, en el
caso de los cuantificadores \texttt{max} y \texttt{min}, una llamada al mensaje
de error apropiado.

  \item [Rango <<unitario>>] se genera el código del cuerpo de la cuantificación
con la sustitución apropiada de la variable \emph{dummy}.

  \item [Rango <<aritmético>>] se genera una iteración en la cual la variable
\emph{dummy} toma todos los valores entre el límite inferior y el superior, y se
evalúa el cuerpo, acumulando los resultados. Existe la posibilidad de que a
tiempo de ejecución esto resulte en un rango vacío, y en este caso el
comportamiento es el esperado, pues la iteración es vacía.

  \item [Rango <<conjunto>>] se genera una iteración en la cual la variable
\emph{dummy} toma todos los valores pertenecientes al conjunto (o multiconjunto,
o secuencia), y se evalúa el cuerpo, acumulando los resultados. En el caso de un
rango secuencia, el órden de la iteración es el mismo de la secuencia, mientras
que para conjuntos y multiconjuntos no se garantiza ningún órden en particular.
De nuevo, es posible que un rango de esta clase resulte en un rango vacío a
tiempo de ejecución, pero el comportamiento sigue siendo el esperado.

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% MANEJO DE APUNTADORES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manejo de apuntadores}
\blindtext[1]
  % - malloc
  % - free
  % - Apuntadores y estructuras (malloc recibe tamaño en bytes, debe ser calculado: getElementPointer)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TEORÍA DE CONJUNTOS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Teoría de conjuntos}
\subsection{Consideraciones}
\blindtext[1]
% - Similares a cuantificaciones, aplican restricciones similares
% - Notación para relation y function:
%     : relation int <-> char, rel(<conjunto de pares>)
%     : function char -> float, func(<conjunto de pares>)

\subsection{Biblioteca externa para teoría de conjuntos}
\blindtext[1]
% - Backend en C++ (std)

\subsection{Generación de código intermedio}
\blindtext[1]
% Conjuntos

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TIPOS DE DATOS (...) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tipos de datos definidos por el programador}
\blindtext[1]
\subsection{Consideraciones}
%  - breve discusión de Carroll Morgan
%  - LA GRAMÁTICA VA AL FINAL PERO IGUAL HABLAMOS SOBRE ELLA
% ¿Qué es un tipo de dato (abstracto/concreto)?
        % - Consideraciones
        % - Qué significa que un TDC implemente un TDA, relación de refinamiento
        % - Variables de tipo
        % - Invariantes de representación, acoplamiento
        % - Procedimientos y Funciones de/sobre un TAD
\subsection{Generación de código intermedio}
% TDDDPEU
% Variables de tipo
% - Invariantes de representación, acoplamiento
%     - Invariante de acoplamiento "compilable"
% - Procedimientos y Funciones de/sobre un TAD

\subsection{Verificación de tipos}
\blindtext[1]
% - breve discusión de =:= y <> de tipos, también de funciones con argumentos
%   con variables de tipo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% HERRAMIENTAS PARA EL PROGRAMADOR %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Herramientas para el programador}
% \subsection{Colección de programas}
% \blindtext[1]
% % Referencia a los anexos
\subsection{Facilidad de instalación para usuarios noveles}
\blindtext[1]

\subsection{Depuración y análisis de rendimiento}
\blindtext[1]
