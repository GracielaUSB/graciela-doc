\chapter{Desarrollo}
\label{capitulo3}
\lhead{Capítulo 3. \emph{Desarrollo}}

El diseño y desarrollo de la extensión al compilador de Graciela fueron llevados
a cabo entre marzo y noviembre del año 2016. Luego de una primera etapa de
revisión del trabajo previo, el proyecto se orientó en cuatro áreas, a saber,
(1) Manejo de apuntadores, (2) Teoría de Conjuntos, (3) Tipos de datos definidos
por el programador, (4) Herramientas para el programador.

Durante el transcurso del proyecto, se escribieron múltiples programas de prueba
con el fin de evaluar los distintos módulos del compilador. Estos programas de
prueba pueden conseguirse en el anexo \textbf{NUMERODEANEXO}.

% El diseño y desarrollo de la extensión al compilador de Graciela fueron llevados
% a cabo en tres etapas, entre marzo y noviembre del año 2016. En la primera
% etapa,
%#  se estudió el estado del compilador elaborado por Araujo y Jiménez,
%#  se evaluaron las recomendaciones que sobre la semántica de este lenguaje hizo el
%# jurado de este primer proyecto,
%  se revisó la bibliografía relacionada con el manejo de tipos definidos por el
% usuario en el contexto de programación formal,
%  se investigó sobre posibles estructuras de datos para implantar tipos que modelen la teoría de conjuntos,
%  se especificó formalmente la sintaxis para las nuevas funcionalidades propuestas
% y
%  se extendieron los analizadores lexicográfico y sintáctico para concordar con
% dicha especificación formal.
%
% En la segunda etapa,
%  se completó la verificación de tipos en presencia de tipos definidos por el
% usuario y tipos que modelan la teoría de conjuntos,
%  se extendió la biblioteca
% externa de Graciela para soportar expresiones de tipos que modelan la teoría de
% conjuntos,
%  se inició la extensión al generador de código intermedio LLVM para producir las
% instrucciones correspondientes a las nuevas funcionalidades y
%  se escribió una colección de programas que ejercitan las capacidades del
% lenguaje, tanto nuevas como originales, a fin de evaluar que el código generado
% fuera correcto.
%
% En la tercera etapa,
%  se culminó la extensión al generador de código intermedio iniciada en la etapa
% anterior,
%  se extendió el manual de usuario para presentar las nuevas funcionalidades del
% lenguaje,
%  se investigaron formas para permitir que usuarios noveles instalen el compilador
% sin mayor dificultad
%  se estudiaron las herramientas necesarias para incorporar facilidades de
% depuración (\emph{debugging}) y análisis de rendimiento (\emph{profiling}) al
% compilador.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% REVISIÓN DEL TRABAJO PREVIO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{section}{-1}
\section{Revisión del trabajo previo}

En la primera etapa de este proyecto, se estudió el estado del compilador
elaborado por Araujo y Jiménez y se evaluaron las recomendaciones que sobre la
semántica de este lenguaje hizo el jurado de este primer proyecto.

Se observó que existían aspectos del compilador que podían ser mejorados, y que
además estas mejoras facilitarían el desarrollo de los objetivos del proyecto,
por lo cual se decidió hacer los cambios que se mencionan en esta sección.

% - Reestructuración de la gramática de los programas en Graciela

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Recomendaciones del Jurado del proyecto de grado de Araujo y Jiménez}
%% TODO!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Modularización de la base de código}

La base de código que recibimos, en la forma de un repositorio \emph{git},
consistía de unos veinticinco archivos escritos en \emph{Haskell} organizados en
un solo directorio. No existía entre estos archivos gran separación de
responsabilidades y varios de ellos contenían código para acciones que no
guardaban relación entre ellas. En particular, se encontró que el Árbol
Sintáctico Abstracto (\textsc{ASA}) estaba representado como un solo tipo de
datos con más de cuarenta constructores distintos.

Así, se decidió separar el código fuente del compilador en cuatro áreas:
\begin{itemize}

  \item Estructuras de datos para representar el \textsc{ASA} de un programa
  escrito en Graciela. Almacenado en el directorio \texttt{AST}, por las siglas
  en inglés para \textsc{ASA} (\emph{Abstract Syntax Tree}).

  \item Análisis sintáctico para convertir un archivo de código Graciela en un
  ASA, verificando simultáneamente su corrección. Almacenado en el directorio
  \texttt{Parser}, por el término en inglés para análizador sintáctico.

  \item Generación de código intermedio LLVM para programas escritos
  correctamente en Graciela que ya han sido convertidos en un ASA. Almacenado en el
  directorio \texttt{LLVM}.

  \item Código que se usa en más de una de las áreas anteriores, como la Tabla
  de Símbolos del compilador y las estructuras de datos para la emisión de
  mensajes de error, y el archivo principal del compilador. Almacenado en el
  directorio raíz del código fuente.

\end{itemize}

En cada una de las primeras tres áreas, se separaron a su vez los procedimientos
y estructuras según la parte del lenguaje Graciela que se estuviera tratando.
Así, el archivo \texttt{AST/Expression.hs} contiene las estructuras de datos
para representar únicamente las expresiones del lenguaje Graciela como un
\textsc{ASA}, mientras que \texttt{Parser/Expression.hs} contiene la lógica del
analizador sintáctico para interpretar y verificar la corrección de las
expresiones, y \texttt{LLVM/Expression.hs} contiene las reglas de traducción de
\textsc{ASA} a código intermedio \textsc{LLVM} para expresiones.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Recuperación de errores en análisis sintáctico}

También se observó que, enfrentado a archivos Graciela con errores sintácticos,
el compilador producía errores difíciles de interpretar. Si bien no es sencillo
generar mensajes de error y continuar el proceso de análisis sintáctico para
archivos que no pertenecen a la gramática del compilador, esta es una
característica que se espera de cualquier compilador si se desea popularizar su
uso.

Desafortunadamente, la biblioteca de análisis sintáctico con la que había sido
desarrollado el proyecto, \texttt{Parsec}, no está diseñada para ofrecer
recuperación de errores, de modo que cualquier solución que usara esta
biblioteca tendría problemas en este aspecto, o al menos resultaría compleja y
más propensa a defectos de programación.

Así, se investigaron bibliotecas alternativas para análisis sintáctico y se
consiguió \texttt{Megaparsec}. Como se explica en el Marco Tecnológico
\todo{explicar en el Marco Tecnológico}, \texttt{Megaparsec} provee el
combinador \texttt{withRecovery}, que permite agregar recuperación de errores a
un analizador sintáctico de manera sencilla. Este combinador recibe una función
de recuperación y un analizador sintáctico base, y ejecuta la primera cuando
dicho analizador falla. Por ejemplo, para agregar recuperación de errores a las
instrucciones, separadas por punto y coma, se usó código como el siguiente:

\begin{haskellcode}
  withRecovery recover instruction
    where
      recover err = void anyToken `manyTill` match TokSemicolon >> tell err
\end{haskellcode}

Así, con ligeros cambios según el contexto del analizador, fue posible agregar
recuperación de errores al compilador.

Otra ventaja de la biblioteca \texttt{Megaparsec} sobre \texttt{Parsec} es que
el \emph{Monad} provisto por la primera, a diferencia del provisto por la
segunda, puede ser utilizado \emph{dentro} de Transformadores de \emph{Monad}s,
permitiendo acumular distintos efectos en una pila de \emph{Monad}s. La utilidad
de esto quedará más clara en la subsección sobre Cuantificaciones.

Finalmente, por tratarse de una bifurcación (\emph{fork}, en inglés) de la
biblioteca \texttt{Parsec}, la mayoría de sus combinadores son idénticos o muy
similares a los de dicha biblioteca, lo cual permitió que la migración del
código de una biblioteca a la otra fuera muy simple.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Consideraciones sobre arreglos}

Durante la revisión del compilador original, se consiguió que, como en la
mayoría de los lenguajes de bajo nivel, no se ofrecía verificación de acceso a
arreglos dentro de los límites de los mismos. A pesar de que implantar este tipo
de verificaciones no formara parte explícita de los objetivos del proyecto, se
consideró que podría agregarse esta funcionalidad para mejorar la experiencia
del programador novel.

También se consideró que sería cómodo para el programador poder hablar de
arreglos multidimensionales en lugar de arreglos de arreglos, y así recibir
errores apropiados, a tiempo de compilación, al usar un arreglo de \texttt{n}
dimensiones con un número de índices distinto de \texttt{n}. Por ejemplo,
intentar compilar el siguiente fragmento de código,

\begin{gracielacode}
  |[ var arr : array [5, 10] of int
  ;  writeln(arr[3])
  ]|
\end{gracielacode}

emitiría un mensaje de error acerca del uso de un índice de dimensión 1 para
leer de un arreglo de 2 dimensiones. En la versión original del compilador, la
situación equivalente produciría un error acerca de intentar imprimir un objeto
de tipo arreglo de entero, que no expresa el verdadero problema del caso.

Para evitarle confusión a los programadores, se eliminó la posibiliad de
declarar arreglos de arreglos, y se emite un error a tiempo de compilación
cuando esto se hace, sugiriendo en cambio utilizar arreglos multidimensionales.

Para implementar estos cambios, fue necesario cambiar la representación interna
de los arreglos. Originalmente, funcionaban como los arreglos del lenguaje C; es
decir, declarar un arreglo \texttt{x} de tamaño \texttt{tam} de elementos de
tipo \texttt{T}, era equivalente a reservar un espacio en la pila de tamaño
$\texttt{sizeof(T)} * \texttt{tam}$ y asociarle al identificador \texttt{x} el
apuntador al primer elemento. Los arreglos multidimensionales se escribían como
arreglos de arreglos, e internamente ocupaban un espacio contiguo de memoria.
Como se deseaba almacenar los tamaños de los arreglos junto con sus elementos,
se decidió usar una representación interna similar a la de arreglos
conformantes, es decir, una estructura cuya primera entrada es la cantidad de
elementos y cuya segunda entrada es el bloque de memoria donde se almacenan los
elementos.

Específicamente, para arreglos de \texttt{n} dimensiones, se generan estructuras
<<cabecera>> de \texttt{n+1} campos, donde los primeros \texttt{n}, de tipo
entero de 32 bit, corresponden a los tamaños en cada dimensión del arreglo, y el
último corresponde a un apuntador a un espacio de memoria contiguo de tamaño
$\texttt{sizeof(T)} * \prod\limits_{i=1}^\texttt{n} dimensi\acute{o}n_i$, que se
reserva en el mismo tipo de memoria que la <<cabecera>>, es decir, en la pila si
es un arreglo estático, o en la memoria dinámica si se trata de un apuntador a
un arreglo inicializado con la instrucción \texttt{new(*)}.

Cuando todas las dimensiones del arreglo son conocidas a tiempo de compilación,
los tamaños de cada dimensión son almacenados estáticamente en la <<cabecera>> y
se reserva el espacio para los elementos en el tipo de memoria apropiado. Cuando
este no es el caso, se genera el código para, a tiempo de ejecución, evaluar la
expresión correspondiente a cada dimensión del arreglo, almacenar en el campo
correspondiente de la cabecera el valor resultante, y reservar el espacio para
los elementos en el tipo de memoria apropiado.

El hecho de que sean almacenados en dos partes podría causar preocupaciones
respecto a la liberación de memoria ocupada por arreglos dinámicos. Sin embargo,
este caso fue tomado en cuenta y la liberación de memoria procede en dos partes,
liberando primero el bloque de elementos, y posteriormente la <<cabecera>>.

La última consideración sobre los arreglos está asociada con su uso como
parámetros de subrutinas (procedimientos y funciones). Se agregó al lenguaje la
capacidad para usar arreglos como parámetros de los modos in, inout y out,
además del modo ref ya provisto en la especificación original. Adicionalmente,
se decidió permitir el pase de arreglos de tamaño variable como parámetros
siempre que todas las variables en las expresiones que denotan su tamaño sean
parámetros anteriores de la subrutina, pasados en modo \texttt{const} en el caso
de los procedimientos. Por ejemplo, la firma del siguiente procedimiento sería
aceptada por el compilador:

\begin{gracielacode}
  proc sub(const size : int, inout arr : array [size, size * 2] of int)
\end{gracielacode}

Desafortunadamente, un procedimiento (o una función) con una firma similar a la
de \texttt{sub} podría ser llamado con argumentos que no concuerden, por
ejemplo,

\begin{gracielacode}
  |[ var arr : array [5, 5]
  ;  sub (5, arr)
  ]|
\end{gracielacode}

En este caso, el procedimiento \texttt{sub} espera un arreglo rectangular de
tamaño \texttt{[size, (size * 2)]}, y como recibe \texttt{size = 5}, espera que
el tamaño del arreglo sea \texttt{[5, 10]}. Sin embargo, recibe un arreglo de
tamaño \texttt{[5, 5]}, por lo cual la ejecución debe abortar al momento de esa
llamada. Esta verificación no puede hacerse a tiempo de compilación en el caso
general, puesto que sería necesario \todo{consultar esto con Monascal}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Consideraciones sobre funciones y procedimientos}

Se decidió cambiar ligeramente la gramática de las funciones y procedimientos
para que fueran más similaras a sus equivalentes en GCL. Simplemente, se
eliminaron los lexemas \texttt{begin} y \texttt{end}, antes usados para
delimitar el procedimiento, y el lexema \texttt{:} entre el identificador de la
subrutina y su lista de parámetros, y se movió la poscondición junto a la
precondición, antes del cuerpo de la subrutina.

Además, se agregó la posibilidad de especificar cotas para las subrutinas luego
de la poscondición y antes del cuerpo, como requisito para hacer llamadas
recursivas dentro de la misma. Así, es un error a tiempo de compilación escribir
una llamada recursiva de una subrutina sin cota. En el caso contrario, el de una
subrutina con cota pero sin recursión, ésta simplemente es ignorada. A pesar de
que esto no estaba dentro de los objetivos de este proyecto, se consideró de
suma importancia, puesto que la recursión sin cotas es equivalente a la
iteración sin cotas, prohibida en el caso de la instrucción \texttt{do .. od}.

El código intermedio LLVM generado para una subrutina recursiva, necesariamente
con cota, además de incluir el cuerpo especificado por el programador, incluye
verificaciones para el decrecimiento y la no-negatividad de la cota. Esto se
logra pasando dos parámetros adicionales a las subrutinas recursivas. El
primero, de tipo booleano, indica si la llamada en curso es la primera llamada a
la subrutina o si se trata de una llamada recursiva. En ambos casos, al entrar a
la subrutina se calcula el valor de la cota, y si es negativa se da un error y
el programa aborta. En caso contrario, si se trata de la primera llamada a la
subrutina, se ejecuta el cuerpo de ésta, pero si se trata de una llamada
recursiva, se compara la cota actual con la anterior, recibida como el segundo
parámetro implícito. Si no hubo decremento en la cota, también se da un error y
el programa aborta. En caso contrario, se ejecuta el cuerpo de la subrutina.

Por último, cabe mencionar que se cambió la semántica del modo de parámetros
\texttt{in}, de forma que los parámetros declarados con este modo pueden ser
reasignados dentro del cuerpo del procedimiento sin afectar el valor del
argumento usado en el punto de llamada. Originalmente, los parámetros de modo
\texttt{in} no podían ser reasignados, pero se consideró que sería conveniente
poder reasignarlos para ofrecer la posibilidad de usar parámetros por su valor
pero aprovechando su espacio en memoria. El comportamiento asociado
anteriormente al modo \texttt{in} ahora corresponde al modo de parámetros
\texttt{const}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Consideraciones sobre cuantificaciones}

Durante el análisis del compilador original, se conoció que las cuantificaciones
presentaban limitaciones en la expresividad de sus rangos. El analizador
sintáctico de esta parte del lenguaje esperaba, específicamente, dos
comparaciones aritméticas, separadas por un operador de conjunción
(\texttt{/\textbackslash{}}), seguidas por un lexema <<barra vertical>>
(\texttt{|}). Esto impedía expresar condiciones lógicas distintas de
comparaciones aritméticas, como predicados definidos por el programador, o
incluso condiciones con más de dos comparaciones aritméticas.

Para solucionar esto, se agregó un estado al analizador sintáctico de las
expresiones, usando el \emph{Monad Transformer} \texttt{StateT} sobre el
\emph{Monad} \texttt{Parsec}. En este estado, se guarda información sobre la
pila de variables \emph{dummy} presentes en un momento dado (la pila vacía en el
caso de las expresiones sin cuantificaciones). Además, se permitió que el
analizador sintáctico de las expresiones devolviera, además de la expresión
conseguida, el rango asociado a ella. Por ejemplo, con la variable \emph{dummy}
\texttt{x}, la expresión \texttt{x >= 5} tiene asociado el rango $[5, \infty)$.

Cuando el analizador sintáctico se encuentra en una cuantificación, agrega la
variable \emph{dummy} correspondiente a la pila del estado, e intenta construir
un rango. Los únicos operadores que construyen rangos son la igualdad
(\texttt{==}), que construye rangos <<unitarios>>; las comparaciones aritméticas
(\texttt{>}, \texttt{>=}, \texttt{<}, \texttt{<=}), que construyen rangos
<<aritméticos>>; y el operador <<pertenece>> de la Teoría de Conjuntos ($\in$)
\todo{los conjuntos y demás tipos de la teoría de conjuntos se explican más
adelante, ¿cómo decir eso?}, que produce rangos <<conjunto>>, mientras que la
constante booleana \texttt{false} produce el rango <<vacío>>.

Además, el operador de conjunción (\texttt{/\textbackslash{}}) devuelve, si es
posible, el rango que resulta de intersectar los rangos asociados a cada uno de
sus operandos. A diferencia de las cuantificaciones lógicas, sin embargo, no se
consideran los rangos generados por el operador de disjunción
(\texttt{\textbackslash{}/}), por lo cual si se desea que un rango sea procesado
como tal, debe estar escrito en Forma Normal Conjuntiva. Esto no le resta
expresividad al lenguaje, ya que pueden conseguirse expresiones equivalentes con
el uso de teoremas lógicos, convirtiendo una cuantificación en la disjunción de
varias, o usando el operador de unión de conjuntos ($\cup$).

Finalmente, si se ha construido un rango válido, este se registra en
el ASA correspondiente a la cuantificación. Si el rango es <<aritmético>>, se
exige que existan límites superior e inferior, emitiéndose el error apropiado en
caso de faltar uno de los límites. Cabe mencionar que si la variable
\emph{dummy} es de tipo número de punto flotante, las comparaciones
aritméticas \emph{no} generarán rangos, puesto que es imposible iterar sobre
números de este tipo.

El código intermedio LLVM generado para cada cuantificación dependerá de la
clase del rango sobre el cual esté definida:

\begin{description}

  \item [Rango <<vacío>>] se genera el valor neutro del cuantificador, o, en el
caso de los cuantificadores \texttt{max} y \texttt{min}, una llamada al mensaje
de error apropiado.

  \item [Rango <<unitario>>] se genera el código del cuerpo de la cuantificación
con la sustitución apropiada de la variable \emph{dummy}.

  \item [Rango <<aritmético>>] se genera una iteración en la cual la variable
\emph{dummy} toma todos los valores entre el límite inferior y el superior, y se
evalúa el cuerpo, acumulando los resultados. Existe la posibilidad de que a
tiempo de ejecución esto resulte en un rango vacío, y en este caso el
comportamiento es el esperado, pues la iteración es vacía.

  \item [Rango <<conjunto>>] se genera una iteración en la cual la variable
\emph{dummy} toma todos los valores pertenecientes al conjunto (o multiconjunto,
o secuencia), y se evalúa el cuerpo, acumulando los resultados. En el caso de un
rango secuencia, el órden de la iteración es el mismo de la secuencia, mientras
que para conjuntos y multiconjuntos no se garantiza ningún órden en particular.
De nuevo, es posible que un rango de esta clase resulte en un rango vacío a
tiempo de ejecución, pero el comportamiento sigue siendo el esperado.

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% MANEJO DE APUNTADORES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manejo de apuntadores}

\subsection{Consideraciones}
Los apuntador implementados para el lenguaje graciela pueden apuntar a un
objeto cualquier tipo básico, arreglo o tipo definido por el programador. La
sintaxis para declarar un apuntador es parecida a la presente en  el lenguaje
C, es decir, se escribe el tipo base seguido de tantos asteriscos (\texttt{*})
como apuntadores se desee. El operador para acceder a la memoria apuntada por
un apuntador es igualmente el asterisco, el cual debe colocarse como operador
prefijo a una expresión de tipo apuntador.

La reserva y liberación de memoria dinámica para un apuntador se realiza con las
funciones propias del lenguaje \texttt{new} y \texttt{free}, ambas con
consideraciones adicionales para el caso de apuntadores a arreglos y apuntadores
a tipos definidos por el programador, que se describen detalladamente en sus
respectivas secciones. El siguiente fragmento de código ejemplifica la
declaración y uso de un apuntador a entero.

\begin{gracielacode}
  |[ var p : int*
  ;  new(p)
  ;  *p := 10
  ;  free(p)
  ]|
\end{gracielacode}

\subsection{Generación de código intermedio}

LLVM ofrece un soporte completo para el manejo de apuntadores, lo que facilitó
enormemente la tarea de implementar la generación de código intermedio para el
manejo de apuntadores. Sin embargo, carece de instrucciones para la reserva y
liberación de memoria dinámica, razón por la cual hubo la necesidad de colocar
funciones en la biblioteca externa que recibieran como argumento al apuntador en
cuestión, y que a su vez llamaran rutinas del lenguaje C que se ocupasen de
realizar dichas operaciones.

En el momento en que se crea un apuntador, éste se inicializa con un valor nulo,
evitando así poder acceder a una dirección basura. En caso de tratar acceder a
la memoria apuntada por un apuntador que contenga la dirección nula, se emite un
error a tiempo de ejecución que indica el lugar de dicho acceso, impidiendo que
sea el sistema operativo quien emita el error.

Para la reserva de memoria dinámica, se utilizó la función estandar de C
\texttt{calloc}, la cual reserva la cantidad de memoria que se le da como
argumentos e inicializa todos los bytes a 0. Por otro lado, la liberación de
memoria dinámica se realiza llamando a la función estandar de C \texttt{free} y
luego asignando al apuntador un valor nulo, para evitar que el programador pueda
interactuar con las direcciones de memorias previamente liberadas. En caso de
tratar de liberar un apuntador mas de una vez o si este contenia un valor nulo,
se emite un error a tiempo de ejecución indicando el lugar donde se realizó la
operación, en lugar de permitir que sea la función \texttt{free} quien emita el
error.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TEORÍA DE CONJUNTOS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Teoría de conjuntos}
\subsection{Consideraciones}

Para permitir mayor expresividad en las aserciones del lenguaje, específicamente
en aquellas asociadas con los tipos de datos definidos por el programador, como
invariantes de representación y de acoplamiento, se decidió agregar al lenguaje
Graciela facilidades para escribir expresiones de la teoría de conjuntos.

Específicamente, se decidió permitir la escritura de expresiones de tipo
conjunto, multiconjunto, y secuencia (usaremos el término \textit{colección}
para referirnos a los tres tipos indistintamente). Sólo se permite que estos
tipos \textit{colección} alberguen objetos de un solo tipo básico, es decir,
sólo se permiten colecciones de enteros, caracteres, números de punto flotante o
valores booleanos, o pares de objetos de tipos básicos, y nunca colecciones de
colecciones, ni colecciones con enteros y caracteres a la vez. Como las
variables de tipos siempre serán instanciadas en tipos básicos, como se explica
en \todo{sección sobre variables de tipos}, también se permiten colecciones de
objetos del tipo de una variable de tipo ligada en el punto donde sea definida
la colección.

Para distinguir gráficamente los conjuntos y los multiconjuntos, se decidió usar
los símbolos \texttt{\{} y \texttt{\}} para los primeros y \texttt{\{\{} y
\texttt{\}\}} para los segundos. Esto se hizo a diferencia de lo usual en
discusiones teóricas, que es usar el primer par de símbolos para ambos tipos de
colección, ditinguiendo según el contexto, para permitir identificar la
colección en cuestión a simple vista. Por otro lado, para representar secuencias
se decidió usar los símbolos \texttt{<\null<} y \texttt{>\null>}.
Adicionalmente, si se usan caracteres UTF-8, los multiconjuntos pueden ser
representados con los símbolos \texttt{\Lbag} y \texttt{\Rbag}, y las secuencias
con \texttt{\Lseq} y \texttt{\Rseq}.

Para proveer un nivel de abstracción similar al de la teoría manejada en los
cursos de algoritmos básicos \todo{revisar esto}, se permite escribir
colecciones de dos maneras, por extensión y por comprensión. En el primer caso,
simplemente se nombran los elementos de la colección separados por comas,
existiendo la posibilidad de no especificar elementos para la colección vacía.
Así, el conjunto, multiconjunto y secuencia con los números 1, 2 y 3 pueden
escribirse en Graciela, respectivamente, como

\begin{gracielacode}
   {1, 2, 3}
  {{1, 2, 3}} // ó ~\Lbag~1, 2, 3~\Rbag~
  <<1, 2, 3>> // ó ~\Lseq~1, 2, 3~\Rseq~
\end{gracielacode}

En el caso de las colecciones definidas por comprensión, se usa una notación
bastante similar a la de las cuantificaciones. Esta notación consiste en tres
partes escritas entre los símbolos correspondientes a la colección deseada y
separadas por caracteres \texttt{|}. En la primera parte se define una variable
auxiliar o \textit{dummy} con uno de los tipos permitidos para colecciones. En
la segunda, el rango, se delimita el rango de la variable auxiliar, con las
mismas consideraciones que para las cuantificaciones. La tercera parte, el
cuerpo, es la expresión que será agregada a la colección para cada valor posible
de la variable auxiliar. Así, las mismas colecciones del ejemplo anterior
podrían escribirse, respectivamente, como

\begin{gracielacode}
   {i : int | 0 < i /\ i < 4 | i}
  {{i : int | 0 < i /\ i < 4 | i}} // ó ~\Lbag~i : int | 0 < i /\ i < 4 | i~\Rbag~
  <<i : int | 0 < i /\ i < 4 | i>> // ó ~\Lseq~i : int | 0 < i /\ i < 4 | i~\Rseq~
\end{gracielacode}

Además de permitir el uso de expresiones de tipos \textit{colección}, es
necesario permitir la declaración de variables con estos tipos. La notación para
esto es la misma que para las declaraciones de tipos básicos, cambiando el tipo
usado. Así, para definir, respectivamente, un conjunto, un multiconjunto, y una
secuencia de enteros, se usa la siguiente notación:

\begin{gracielacode}
  var x : set of int;
  var y : multiset of int;
  var z : sequence of int;
\end{gracielacode}

Además de las colecciones, se agregaron al lenguaje los tipos abstractos de la
teoría de conjuntos \textit{función} y \textit{relación}. En la mayoría de la
literatura que hace uso de la teoría de conjuntos, estos tipos no son más que
conjuntos de pares ordenados, con la restricción adicional de que no pueden
pertenecer a la misma función dos pares con el mismo primer elemento. En el
lenguaje Graciela, para distinguir visualmente estos tipos de los
conjuntos sencillos, y entre ellos, se optó por definir las funciones
\texttt{func} y \texttt{rel}, que toman un conjunto de pares ordenados (A, B),
donde A y B son tipos básicos posiblemente distintos, y devuelven,
respectivamente, la función de A en B y la relación entre A y B correspondientes
al conjunto de pares dado. Adicionalmente, en el caso en que el conjunto pasado
a \texttt{func} contuviese dos pares ordenados con el mismo primer elemento, se
daría un error a tiempo de ejecución, por incumplirse la definición matemática
de \textit{función}.

De manera similar a las colecciones, se permite la declaración de funciones y
relaciones entre dos tipos, con la siguiente notación, respectivamente:

\begin{gracielacode}
  var x : function int -> char;
  var y : relation int <-> char;
\end{gracielacode}

Finalmente, se agregaron los operadores usuales de la teoría de conjuntos. Se
hace una exposición de ellos en el apéndice NUMERODEAPENDICE.

\subsection{Biblioteca externa para teoría de conjuntos}

Internamente, los valores de la teoría de conjuntos son manejados como
apuntadores a las estructuras correspondientes ofrecidas por la biblioteca
estándar del lenguaje C++. Esto se hace de manera transparente al programador,
por lo cual éste no debe preocuparse por manejar dichos apuntadores. Como  estas
estructuras se crean de manera dinámica y su manejo es responsabilidad del
compilador y de la biblioteca externa, se diseñó un sencillo manejador de
memoria dinámica que libera el espacio asignado a dichas estructuras cada vez
que salen de alcance. Si el programa termina de manera inesperada por haberse
incumplido una aserción, o por haber alcanzado un condicional sin guardas
verdaderas, este manejador de memoria se encarga de liberar toda la memoria
reservada para estas estructuras.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TIPOS DE DATOS (...) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tipos de datos definidos por el programador}

%  - breve discusión de Carroll Morgan --> Marco Teórico
%  - LA GRAMÁTICA VA AL FINAL PERO IGUAL HABLAMOS SOBRE ELLA -> SOBRE TODO EL WHERE

% ¿Qué es un tipo de dato (abstracto/concreto)?

\subsection{Consideraciones}
% - Consideraciones

El objetivo principal de este proyecto es agregar al lenguaje Graciela y a su
compilador, las características y el soporte necesarios para permitir al
programador definir tipos de datos estructurados abstractos o TDA. Como se busca
lograr que el lenguaje Graciela cuente con la misma expresividad del lenguaje
GCL, es necesario que su compilador permita definir restricciones y
comportamientos abstractos para estos tipos, a través del uso de aserciones de
alto nivel como el invariante de representación y las precondiciones y
poscondiciones de los procedimientos y funciones que definen su interfaz.
Estos tipos de datos, definidos dentro del lenguaje de programación con la
palabra reservada \texttt{abstract}, nunca definen una implementación en
particular, sino que se limitan, precisamente, a definir los comportamientos que
debería cumplir cualquier estructura de datos que pretenda implementarlos.

Para aprovechar la definición de un tipo de dato abstracto, es necesario definir
un nuevo tipo de dato que, usando únicamente estructuras de bajo nivel y un
invariante de acoplamiento que precise la correspondencia entre estas
estructuras de bajo nivel y las de alto nivel del tipo de dato abstracto, logre
cumplir las restricciones y comportamientos de este último. En adelante, nos
referiremos a estos tipos de datos, los cuales siempre deben implementar un TDA,
como \textit{implementaciones}. Dentro del lenguaje, estos son definidos usando
la palabra reservada \texttt{type} y el TDA implementado se especifica usando la
palabra reservada \texttt{implements}.

Sin embargo, en el caso general, no es posible verificar, a tiempo de
compilación, que una implementación de un tipo de dato, junto con sus
procedimientos y funciones, cumpla a cabalidad con los invariantes y aserciones
del tipo de dato abstracto que se supone implementa. Por lo tanto, se decidió
dejar algunas de estas verificaciones para tiempo de ejecución.

\subsection{Modelo de representación}

Dentro de un tipo de datos se pueden declarar variables y constantes, a los
cuales puede darse un valor inicial en caso de ser de un tipo básico o
apuntador. Estas declaraciones corresponden al modelo de representación del tipo
de dato. Si se trata de un TDA, se pueden declarar variables con un tipo de alto
nivel, es decir, tipos de la Teoría de Conjuntos.

A nivel del código generado, se consideró la posibilidad de mantener estas
variables actualizadas según se ejecuten los distintos procedimientos del TDA,
con cada instrucción produciendo, posiblemente, varias actualizaciones sobre
estas estructuras, en general difíciles de predecir. Inclusive, el código que
manipulara directamente la \textit{implementación} del TDA, fuera de sus
procedimientos, debería ser capaz de actualizar estas estructuras, ya que de lo
contrario se producirían inconsistencias. Así, se optó por no se almacenar de
manera persistente las variables del TDA de tipos de la teoría de conjuntos,
sino por materializarlas, haciendo uso de la relación de acoplamiento, sólo
cuando son necesarias para evaluar las distintas aserciones del TDA, por
ejemplo, al momento de evaluar las precondiciones y poscondiciones de un
procedimiento abstracto.

\subsection{Invariante de representación}

El invariante de representación define las características y restricciones que
deben ser satisfechas por el modelo de representación de un tipo de dato, sea un
TDA o una implementación de un TDA. El invariante de representación se indica
como una expresión booleana contenida entre el par de símbolos \texttt{\{repinv}
y \texttt{repinv\}}. Es importante destacar que, en el caso de las
implementaciones, las variables y constantes del TDA implementado pueden ser
utilizadas dentro del invariante de representación, siempre y cuando no sean de
tipos de la Teoría de Conjuntos.

\subsection{Relación de acoplamiento}

En la literatura, para establecer la relación entre las estructuras de bajo
nivel usadas en la implementación, con las de alto nivel que se encuentran en el
TDA, es decir, se debe definir una correspondencia entre los dos modelos de
representación en la forma de una expresión lógica arbitraria. Como se explica
en la sección anterior sobre el modelo de representación, se decidió que las
estructuras de tipos de la teoría de conjuntos sólo fueran materializadas al
momento de verificar aserciones, es necesario contar con instrucciones para
materializarlas. Sin embargo, las expresiones lógicas arbitrarias no proveen una
manera directa para generar dichas instrucciones, puesto que la lógica
declarativa únicamente especifica propiedades, y deducir valores de estas
propiedades, en el caso general, resulta imposible, puesto que más de un valor
podría satisfacer dicho conjunto de propiedades. 




Cuando se implementa un tipo de dato abstracto, se debe establecer una una
expresión lógica que especifique la relación entre las estructuras de bajo
nivel usadas en la implementación, con las de alto nivel que se encuentran en
el TDA, es decir, se debe definir una correspondencia entre los dos modelos de
representación.


Sin embargo, debido a que en el caso general no es posible
analizar cualquier expresión lógica que determine una relación de
acoplamiento,

se tomarón en cuentas las siguientes consideraciones.



En primer lugar, se agregó sintaxis para poder definir el mecanismo a través
del cual se llevará a cabo la relación entre ambas estructuras. Este mecanismo
se especifica como una serie asignaciónes a las estructuras de alto nivel,
dentro de un bloque precedido por la palabra reservada \texttt{where}. Para
dichas asignaciones, se puede hacer uso de la sintaxis incorporada al lenguaje
para construir expresiones de la Teoría de Conjuntos.

En segundo lugar, debido que representar la relación de acoplamiento como
simples asignaciones hace que el lenguaje pierda expresividad, se decidió
incorporar sintaxis que permitiera agregar restricciones a dicha relación, en
la forma de una expresión booleana contenida por los lexemas
\texttt{\{coupinv} y \texttt{coupinv\}}.



% - Qué significa que un TDC implemente un TDA, relación de refinamiento
% - Invariantes de acoplamiento
% - WHERE

\subsection{Variables de tipo}
Para que el lenguaje Graciela cuente con la expresividad de GCL, es necesario
poder especificar tipos de datos estructurados que no dependan de un tipo
concreto. Para ello se dotó al lenguaje con la capacidad de poder declarar
tipos genéricos que permitan definir aserciones y comportamientos igualmente
genéricos.

Estos tipos genéricos, o variables de tipo, se pueden declarar junto con la
definicion de un tipo de dato y usarse en la especificación interna de éste. Las
variables de tipos solo pueden ser correspondidas con un tipo básico, es decir,
tipo entero, flotante, caracter o booleano. Para usar una variable de de un tipo
de dato definido por el usuario que tenga asociado una o mas variables de tipo,
se debe especificar dicha correspondencia a la hora de definir la variable en
cuestion. Ejemplo de esto, serian las siguientes lineas de codigo.

\begin{gracielacode}
  abstract ConjuntoA (T) begin
    var a : T;
  end

  type Conjunto (N) implements ConjuntoA(N) begin
    var b : N;
  end

  main
   |[ var c : Conjunto(int)
    ; skip
   ]|

\end{gracielacode}

En este caso, se definió un tipo de dato abstracto \texttt{ConjuntoA} y una
implementación \texttt{Conjunto}, ambas asociadas a una variable de
tipo, \texttt{T} y \texttt{N} respectivamente. Como se puede apreciar, el tipo
\texttt{Conjunto} implementa al TDA \texttt{ConjuntoA} con la
variable de tipo \texttt{N}, por lo que cada ocurrencia de \texttt{T} dentro
de la especificación de \texttt{ConjuntoA}, sera sustituida por la variable de
tipo \texttt{N}.

Por otro lado, cuando se declara la variable \texttt{c}, es necesario indicar un
tipo concreto, en este caso \texttt{int}, para el tipo \texttt{Conjunto}. De
esta forma cualquier ocurrencia de \texttt{N}, dentro de la especificación de
\texttt{Conjunto} y \texttt{ConjuntoA}, es sustituido por el tipo \texttt{int}.



% - Variables de tipo

\subsection{Procedimientos y funciones}
Como se mencionó previamente, los tipos de datos abstractos definen una
interfaz. Esta interfaz se compone de una serie de procedimientos y funciones,
cada una con sus respectivas precondiciones y poscondiciones.

Para definir una implementación de un tipo abstracto, se deben definir la
implementación de todos los procedimientos y funciones que se encuentran en la
interfaz del TDA, junto con un nuevo par de precondiciones y poscondiciones.
Sin embargo, pueden agregarse nuevos procedimientos y funciones adicionales.

Cabe mencionar las siguientes consideraciones:

\begin{itemize}

  \item Si un procedimiento posee algun uso de una variable de tipo, es
  necesario que al menos uno de sus parametros sea del tipo de dato dentro del
  cual se definio dicho procedimiento.

  \item Dentro de un tipo de dato, cada procedimiento debe tener un nombre único.
  Sin embargo, ese nombre puede ser reutilizado en otro tipo de dato, siempre
  y cuando uno de sus parametros sea del tipo de dato en cuentión. Al momento
  de evualuar cual procedimiento se debe escoger, se toma el primer
  argumento, de izquierda a derecha, cuyo tipo sea un tipo de dato definido por
  el usuario, como el desempate. En caso de haber más de un procedimiento que
  no cumpla esta condición, se toma como un caso ambiguo y se emite un error.

\end{itemize}

Estas consideraciones aplican igualmente para funciones.

% - Procedimientos y Funciones de/sobre un TAD

\subsection{Generación de código intermedio} Durante el analisis sintáctico, se
registran todos los usos de un tipo de dato definido por el usuario, y los
diferentes tipos concretos que se les asigno en cada uso. De esta forma, para un
tipo \texttt{Diccionario(T0,T1)}, se toma nota de cuales usos se le dieron y con
cuales tipos basicos. Si los usos fueron \texttt{Diccionario(int, char)} y
\texttt{Diccionario(int, float)}, al llegar a la fase de generación de codigo
intermedio, se generan dos estructuras de bajo nivel llamadas con el nombre del
tipo en cuentión seguido de las iniciales de los tipos basicos utilizados
separados por guiones, es decir, \texttt{Diccionario-i-c} y
\texttt{Diccionario-i-f}, ambas conteniendo los campos de la implementación y
del TDA. Cabe destacar, que nunca se generan estructuras en el codigo intermedio
para los TDA.

Es necesario destacar que los arreglos, al estar divididos en una cabezera y
un cuerpo, solo la cabezera es incluida dentro de la estructura. El cuerpo es
reservado aparte en la pila en caso de ser una variable estatica, o en memoria
dinamica en caso de tratarse de un apuntador.

\subsubsection{Invariantes de representación y de acoplamiento}
Por cada estructura generada para cada tipo de dato, se generan
automaticamente tres subrutinas. Dos rutinas para el invariante de
representación del TDA y de la implementación respectivamente, y una para la
relación de acoplamiento. Estas rutinas seran llamadas repetidamente dentro de
las verificaciones de cada procedimiento y funcion dentro del tipo de dato.

\subsubsection{Procedimientos y funciones} Para los procedimientos y funciones
debemos considerar dos casos. Si el procedimiento no hace uso alguno de una
variable de tipo, se genera una unica rutina en codigo intermedio. Por otro
lado, si hizo uso de una variable de tipo, se generan tantas rutinas en codigo
intermedio como estructuras del tipo de dato en cuestión se hayan generado. De
esta forma, para el procedimiento \texttt{agregar} del tipo
\texttt{Diccionario(int,char)}, se declaran dos rutinas en codigo intermedio
llamadas \texttt{agregar-Conjuto-i} y \texttt{agregar-Conjunto-f}.

Con respecto a la verificación de las precondiciones, poscondiciones e
invariantes, se tomaron las siguientes consideraciones.

\begin{itemize}

  \item Antes de iniciar con el cuerpo del procedimiento, se
  evalua la precondición de la implementación. En caso de ser falsa, se
  emite una advertencia a tiempo de ejecución y no se hacen mas verificaciones.

  \item Si la precondicion se cumple, se utiliza relación de acoplamiento y se
  evalua de su correspondiente invariante. En caso de que éste último sea
  falso, se emite un error a tiempo de ejecución.

  \item Se procede a evaluar la precondición del TDA y en caso de ser falsa,
  se emite un error a tiempo de ejecución, aclarando que el procedimiento no
  implementa al abstracto.

  \item Luego, para cada argumento cuyo tipo sea un tipo de dato, se verifica
  su invariante de representacion e invariante de representacion del TDA
  correspondiente. Si ambas invariantes se cumplen, se procede a ejecutar el
  cuerpo del procedimiento.

  \item Antes de finalizar el procedimiento, se realiza nuevamente la relacion
  de acoplamiento y el invariante de representación del tipo que implementa y
  el invariante de representación del TDA, en este mismo orden.

  \item Se evalua la precondicion del TDA y en caso de ser falsa se emite un
  error a tiempo de ejecución aclarando que el procedimiento no implementa el
  abstracto.

  \item Por ultimo se evalua la poscondición dela implementación y en caso de
  ser falsa, se emite un error a tiempo de ejecución.

\end{itemize}

Estas consideraciones aplican para las funciones, excepto que los invariantes
no se verifican por segunda vez al salir de la funcion. Esto debido que son
funciones puras y por lo tanto, no realizan cambios en las variables
involucradas.

\subsubsection{Otras rutinas por defecto}
Para cada estructura creada a partir de tipo de dato definido por el usuario,
se generan automaticamente un contructor, un destructor y una rutina para la
copia de las estructuras. estas rutinas contemplan las siguientes
cosideraciónes.

\begin{itemize}

  \item El constructor es llamada cuando se declara una variable del tipo en
  cuestión, o despues de haber reservado memoria para un apuntador del mismo
  tipo. Esta rutina se encarga de asignar a todos los campos de la estructura,
  el valor inicial en caso de tener alguno y llamar a los contructores de las
  estructuras internas.

  \item La rutina de copia se utiliza para copiar la estructura cuando se
  intenta pasar como argumento In o InOut a un procedimiento. La copia llega a
  un nivel superficial cuando de apuntadores se trata.

  \item Antes de liberar un apuntador hacia una estructura, se llama al
  destructor, el cual se encarga de liberar la memoria reservada por el cuerpo
  de los arreglos. Esta rutina se encarga de llamar a los destructores de las
  estructuras internas.

\end{itemize}

% TDDDPEU
% Variables de tipo
% - Invariantes de representación, acoplamiento
%     - Invariante de acoplamiento "compilable"
% - Procedimientos y Funciones de/sobre un TAD
% - Funciones predefinidas (inicializador y destructor)

\subsection{Verificación de tipos}
\blindtext[1]
% - breve discusión de =:= y <> de tipos, también de funciones con argumentos
%   con variables de tipo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% HERRAMIENTAS PARA EL PROGRAMADOR %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Herramientas para el programador}
% \subsection{Colección de programas}
% \blindtext[1]
% % Referencia a los anexos
\subsection{Facilidad de instalación para usuarios noveles}
\blindtext[1]

\subsection{Depuración y análisis de rendimiento}
\blindtext[1]
