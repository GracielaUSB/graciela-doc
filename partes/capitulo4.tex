\chapter{Resultados}
\label{capitulo4}
\lhead{Capítulo 4. \emph{Resultados}}

El resultado del presente Proyecto de Grado es doble, pues se extendió el
lenguaje Graciela para incluir manejo de apuntadores, expresiones de la teoría
de conjuntos y tipos de dato definidos por el programador, y se dotó al
compilador \texttt{graciela} de la capacidad de analizar y generar código para
los usos de estas nuevas características del lenguaje. Adicionalmente, se
mejoraron algunas características ya presentes en el lenguaje y en el compilador
para mejorar la experiencia del programador novel.

\todo{hablar más (?)}

\section{Cambios en la gramática}

Para dar más claridad a los programas escritos en Graciela, se decidió que el
bloque principal debe estar precedido por la palabra clave \texttt{main}.  Por
otro lado, en la definición de procedimientos y funciones, se movió la
poscondición junto con la precondición, de modo que aparecen antes del cuerpo de
la subrutina, eliminándose así la necesidad de usar las palabras clave
\texttt{begin} y \texttt{end} para delimitar el cuerpo de la subrutina. En los
procedimientos, también se eliminó el  símbolo \texttt{:} entre el identificador
del procedimiento y el conjunto de parámetros delimitado por paréntesis, por
carecer de valor semántico \texttt{revisar}.

\section{Recuperación de errores durante el análisis sintáctico}

El compilador \texttt{graciela} cuenta ahora con una mejor capacidad para
recuperarse de errores durante el análisis sintáctico de un archivo, y ofrece
mensajes de error más fáciles de entender en gran parte de los casos.
\todo{ejemplos de esto}

\section{Arreglos}

Para mejorar la experiencia de los programadores del lenguaje Graciela, se
agregaron al lenguaje verificaciones para cada acceso a un arreglo, de modo que
intentar usar posiciones más allá de los límites de un arreglo resulta en un
error a tiempo de ejecución, independientemente de si se intentaba leer del
arreglo o escribir a él. Dado que el uso equivocado de índices sobre arreglos
suele ser una fuente de defectos en el código, esta nueva característica puede
ser de gran utilidad para los estudiantes de los cursos introductorios de
algoritmos.

Por otro lado, se decidió ofrecer arreglos multidimensionales como parte del
lenguaje. Anteriormente, era posible utilizar arreglos multidimensionales
declarándolos como arreglos de arreglos de algún tipo, y para utilizar sus
elementos se hacían tantos usos de subíndices (\texttt{[i]}) como dimensiones
tuviera el arreglo. Ahora, son declarados como arreglos de varias dimensiones,
especificando entre corechetes sus tamaños en cada dimensión, separados por
comas, de la siguiente manera:

\begin{gracielacode}
var unArreglo : array [x, y, z] of int
\end{gracielacode}

Similarmente, para hacer uso de sus elementos, se usan tantos subíndices como
dimensiones tuviera el arreglo de interés, pero entre un mismo par de corchetes,
de la siguiente manera:

\begin{gracielacode}
writeln (unArreglo[1, 2, 3])
\end{gracielacode}

Es importante destacar que si se usa una secuencia de subíndices de más o menos
dimensiones que las que tiene el arreglo que se desea usar, se da un error
bastante claro a momento de compilación, especificando las dimensiones del
arreglo y de la secuencia de subíndices. Esto puede compararse con la
implementación original, en la que el error emitido mencionaría, o bien un
intento de subindizar una variable que no es un arreglo, o bien un intento de
usar un arreglo en donde se esperaba un valor de un tipo básico; estos errores,
a pesar de ser ciertos, no indican la verdadera razón del problema, la falta de
concordancia entre las dimensiones del arreglo y las de la subindización
utilizada.

\section{Subrutinas}

Anteriormente, se permitía que procedimientos y funciones fueran recursivos sin
importar si esta recursión era acotada. De hecho, no existía en la gramática del
lenguaje la posibilidad de dar una cota a procedimientos o a funciones. Ahora,
para poder hacer llamadas recursivas de una subrutina, es necesario declarar
para ella una expresión de cota, la cual, de manera equivalente a la cota de la
instrucción \texttt{do}, será evaluada cada vez que sea llamada la subrutina, y
en caso de no descender, o de volverse negativa, se dará el correspondiente
error a tiempo de ejecución. Si se define una cota para una subrutina que no es
recursiva, esta símplemente es ignorada.

\section{Cuantificaciones}


\subsection{Apuntadores}

Los apuntadores se declaran como cualquier otra variable dentro del lenguaje
Graciela. El tipo de un apuntador se especifica colocando el tipo que se desea
apuntar, seguido de un asterisco (\texttt{*}). Se pueden declarar apuntadores
a tipos básicos, arreglos, tipos definidos por el programador y a otros
apuntadores. De igual forma se pueden especificar parámetros para funciones y
procedimientos con apuntadores. Cabe acotar que para declarar apuntadores a
tipos cuya sintaxis pueda generar ambigüedad, se pueden colocar entre paréntesis
antes de colocar el asterisco. Ejemplo de éste caso seria poder declarar un apuntador a
un arreglo de enteros y un arreglo de apuntadores a entero.

\begin{gracielacode}
var ptrToArray : (array[10] of int)*
var arrayOfPtr :  array[10] of int*
\end{gracielacode}

Una variable de tipo apuntador puede ser comparada con otra, siempre que los
tipos apuntados sean los mismos, haciendo uso de los operadores de igualdad
(\texttt{==}) y desigualdad (\texttt{!=}). Tambien se puede asignar el valor
de un apuntador a otro, siempre y cuando se cumpla la condición mencionada
anteriormente. Se cuenta con el símbolo reservado del lenguaje
\texttt{null}, que representa a la dirección nula y con el que se pueden
realizar comparaciones y asignaciones a cualquier variables de un
tipo apuntador. No está permitida la aritmética de apuntadores ni el uso de
variables de este tipo en las rutinas \texttt{read} y \texttt{write}.

Cuando se declara una variable de tipo apuntador, ésta contendrá la dirección
nula. Para poder reservar memoria dinámica a la cual apuntar, se puede hacer
uso de la rutina propia del lenguaje \texttt{new}, la cual recibe el apuntador
en cuestión y le asigna una sección de memoria inicializada en cero, del
tamaño del tipo interno. Así mismo, debe utilizarse la rutina propia del
lenguaje \texttt{free}, la cual libera la memoria que apunta la variable que
se le es dada como argumento.

Para poder acceder al contenido de un apuntador, se debe usar el operador
prefijo de desreferencia (\texttt{*}). No se permite desreferenciar un
apuntador cuyo valor sea la dirección nula, y caso de realizarlo, se emite un
error durante la ejecución. De este modo, el siguiente código debe ejecutarse
cumpliendo todas las aserciones.

\begin{gracielacode}
main
	|[ var p1, p2 : int*; { p1 == p2 ∧ p2 == null }
	 ; new(p1)            { p1 != null ∧ *p1 == 0 }
	 ; new(p2)            { p2 != null ∧ *p2 == 0 }
	 ; *p1 := 1           { p1 != p2 ∧ *p1 == 1 }
	 ; *p2 := *p1 + 1     { p1 != p2 ∧ *p2 == 2 }
	 ; free(p1)
	 ; free(p2)
	 ; p1 := null         { p1 == null }
	 ; p2 := p1           { p2 == null }
	]|
\end{gracielacode}


\section{Tipos de Datos}
Existen dos clasificaciones de los tipos de datos que pueden definirse en el
lenguaje Graciela, los tipos de datos abstractos o TDA y los tipos de datos
que implementan a un TDA. Estos deben ser definidos dentro del espacio global
de definiciones.

\subsection{Tipos de Datos Abstractos}

Los tipos de datos abstractos pueden declararse con la palabra reservada
\texttt{abstract} seguida de un identificador y, de forma opcional, una
secuencia de variables de tipo dentro de paréntesis y separadas por coma.
Podemos separar la estructura interna de un TDA en tres secciones. Primero se
debe especificar el modelo de representación, en el cual se permite declarar
contantes y variables de cualquier tipo, incluyendo tipos de la Teoría de
Conjuntos. A continuación se debe especificar el invariante de representación
dentro de un bloque contenido por los símbolos \texttt{\{repinv}} y
\texttt{repinv\}}. Por último, se declaran todos los procedimientos y
funciones abstractas con sus respectivas precondiciones y poscondiciones.

Dentro de los procedimientos abstractos de un TDA pueden ser declaradas
variables, especialmente variables de tipo de la Teoría de Conjuntos, con el
fin de poder usarlas dentro de la precondición y la poscondición. Así, un tipo
de dato abstracto \texttt{Diccionario} con un procedimiento para agregar un
elemento, puede declararse de la siguiente forma.

\begin{gracielacode}
abstract Diccionario (T0, T1) begin
  const MAX := 100 : int;
  var   conoc      : set of T0;
  var   tabla      : function T0 -> T1;

  {inv MAX > 0 ∧ #conoc ≤ MAX ∧ conoc == domain(tabla) inv}

  proc agregar (inout d : Diccionario(T0,T1), in c : T0, in v : T1)
  	var tabla' := d.tabla : function T0 -> T1;
    var conoc' := d.conoc : set of T0;
    {pre c ∉ d.conoc ∧ #d.conoc < d.MAX pre}
    {post d.conoc == conoc' ∪ {c}
        ∧ d.tabla == tabla' ∪ func({(c, v)}) post}
end
\end{gracielacode}

\subsection{Implementación de Tipos de Datos Abstractos}

Aquellos tipos de datos que pretendan implementar un TDA, deben ser declarados
con la palabra reservada \texttt{type}, un identificador y sus variables de
tipo, seguido de la palabra reservada \texttt{implements} y el TDA que se
desea implementar. La especificación interna, es similar a la de un TDA, con la
excepción del invariante y relación de acoplamiento.

En primer lugar, el modelo de representación solo puede albergar constantes y
variables de tipos básicos, arreglos, apuntadores y otros tipos de datos
definidos por el programador. A continuación, deben ser especificados el
invariante de representación y el invariante y relación de acoplamiento. El
invariante de acoplamiento se escribe en un bloque contenido por los símbolos
\texttt{\{coupinv}} y \texttt{coupinv\}}, mientras que la relación de
acoplamiento se escribe dentro de un bloque entre llaves y precedido por la
palabra reservada \texttt{where}. La relación de acoplamiento debe especificar
un mecanismo, a través de asignaciones, con el cual poder materializar todas
las variables de alto nivel, encontradas en el TDA sin excepción. El bloque
\texttt{where} es opcional, siempre y cuando el TDA no tenga variables de alto
nivel, mas no se permite que quede vacío.

Los procedimientos y funciones dentro de un tipo de dato se definen como
cualquier otro fuera de éste. Sin embargo, ciertas condiciones aplican al
momento de especificar el tipo de dato. La primera condición, es que todos
procedimientos y funciones halladas en la especificación del TDA deben
implementarse, aunque esto no evita poder definir otros métodos. La segunda
condición es que, cualquier uso de variables de tipo dentro del cuerpo o
cabezera de un método, está restringido al caso en el que uno de los
parámetros del mismo, sea del tipo de dato dentro del cual se está definiendo
y contenga a su vez las variables de tipo en cuestión.

Todas las variables y constantes presentes en el TDA, estarán disponibles en
cualquier lugar del código como uno de los campos de la
\textit{implementación}, si y solo si, no sea de un tipo de la Teoría de
Conjuntos. El único lugar donde se está permitido hacer uso de las variables
de alto nivel del TDA como campos de la \textit{implementación}, es dentro del
invariante y la relación de acoplamiento. De esta forma, una posible
implementación del TDA \texttt{Diccionario} debería verse de la siguiente
manera.

\begin{gracielacode}
type Dicc (T0, T1) implements Diccionario (T0, T1) begin
  var clave : array [MAX] of T0;
  var valor : array [MAX] of T1;
  var tam   : int;

  {repinv MAX > 0 ∧ 0 ≤ tam ∧ tam ≤ MAX ∧
    (\% ∀ i : int | 0 ≤ i ∧ i < tam
      | (\% ∀ j : int | 0 ≤ j ∧ j < tam ∧ i != j | clave[i] != clave[j] \%)
    \%)
  repinv}

  {coupinv true coupinv}

  where {
  	tabla := func({i : int | 0 ≤ i ∧ i < tam | (clave[i], valor[i])});
    conoc := domain(tabla)
  }

  proc agregar (inout d : Dicc (T0,T1), in c : T0, in v : T1)
    var tam' := d.tam : int;
    var clave'        : array[d.MAX] of T0;
    var valor'        : array[d.MAX] of T1;

    {pre ¬(\% ∃ i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == c \%) ∧ d.tam < d.MAX pre}

    {post d.tam == tam' + 1 ∧ d.clave[tam'] == c ∧  d.valor[tam'] == v
              ∧ (\% ∀ i : int | 0 ≤ i ∧ i < tam' | d.clave[i] == clave'[i]
                                                ∧ d.valor[i] == valor'[i] \%) post}
    ⟦
     ...
    ⟧
\end{gracielacode}

Cabe mencionar que no se pueden declarar variables de un TDA fuera del mismo y
pueden existir multiples implementaciones para un mismo TDA.
