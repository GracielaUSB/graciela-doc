\chapter{Marco Teórico}
\label{capitulo1}
\lhead{Capítulo 1. \emph{Marco Teórico}}

\section{Programación formal y tripletas de Hoare}

\section{Teoría de conjuntos}

La Teoría de Conjuntos es la rama de la matemática que se encarga del estudio de
colecciones bien formados de objetos, que pueden o no ser de naturaleza
matemática. Esta teoría surge de la idea original de conjuntos de Georg Cantor,
quien los definió como una colección, finita o infinita, de objetos definidos y
distinguibles, y a su vez los conjuntos pueden ser considerados en sí mismos
como objetos.

A partir de las ideas de Cantor, se comenzó un proceso de axiomatización de la
matemática, con el cual se construyeron en base a los conjuntos otros objetos
matemáticos como los números, las funciones y otras estructuras. De la teoría de
conjuntos podemos destacar las siguientes estructuras:

\begin{description}[leftmargin=!,labelwidth=\widthof{\bfseries Multiconjunto}]

  \item [Conjunto] Los conjuntos son colecciones tales que todos sus elementos
  debes ser distintos entre sí. Cuenta con operadores binarios como la unión, la
  intersección y la resta entre conjuntos, así como el operador complemento, con
  el que se obtiene un nuevo conjunto que contiene todos los elementos, con
  respecto a un universo, que el conjunto original no poseía.

  \item [Multiconjunto] Los multiconjuntos son colecciones en las que cada
  elemento tiene una multiplicidad asociada, es decir, puede contener dos o mas
  elementos que sean idénticos entre sí. Cuenta con los operadores  binarios de
  unión, intersección y resta de multiconjuntos, así como con la suma de
  multiconjuntos.

  \item [Secuencia] Las secuencias son colecciones de objetos enumerados, en las
  cuales se permite la repetición de los mismos. A diferencia del conjunto y el
  multiconjunto, el orden de los elementos sí tiene importancia. Formalmente,
  una secuencia puede ser definida como una función entre los números naturales
  y los elementos de la colección. Cuenta con los operadores de concatenación y
  subindización.

  \item [Relación] Una relación es una asociación entre un conjunto de entrada
  (dominio) y un conjunto de salida (codominio). Formalmente se modelan como
  conjuntos de pares, donde el primer elemento de cada par pertenece al dominio
  y el segundo al codominio.

  \item [Función] Las funciones son relaciones con la restricción de que cada
  elemento del dominio se corresponde con un único elemento del codominio,
  construyendo así un mecanismo que permite transformar cualquier elemento del
  dominio a uno del codominio. De igual forma, las funciones pueden modelarse
  formalmente como un conjunto de pares, donde el primer elemento del par
  pertenece al dominio y el segundo al codominio, pero asegurando que no
  pertenezcan al conjunto dos pares cuyo primer elemento sea igual.

\end{description}

\section{Tipos de datos abstractos}

\section{Tipos Algebraicos Libres}

En la teoría de tipos, un tipo Algebraico libre es una forma particular de tipo
compuesto que permite definir tipos producto y tipos suma, además de tipos que
son una combinación de ambos. Los valores de un tipo producto suelen contener
varios sub-valores de distintos tipos, y el conjunto de valores posibles es el
producto cartesiano de los conjuntos de cada sub-tipo, de ahí la denominación de
tipo <<producto>>. Por otro lado, los tipos suma definen varias \textit{clases}
tales que  los valores de un tipo suma sólo pueden pertenecer a una clase a la
vez, de modo que el conjunto de valores posibles para un tipo suma es la unión
de los valores posibles para cada clase, notando que la cardinalidad de este
conjunto será la suma de los conjuntos de las clases, debido a que son
disjuntos.

El ejemplo motivador en la mayoría de los cursos que hablan sobre Tipos
Algebraicos Libres (TALs) es el del árbol binario. Un lenguaje que soporte TALs
aceptaría una definición como la siguiente.

$$ \textbf{freetype}\ Tree(e)\ = Leaf(e)\ |\ Node(Tree(e),\ Tree(e)) $$

Este TAL es el tipo suma suma de las clases
$Leaf(e)$ y $Node(Tree(e),\ Tree(e))$,
y esta última es, a su vez, un tipo producto de $(Tree(e))$ y $(Tree(e))$.

Otra característica importante de los TALs, que los hace muy útiles, es la
posibilidad de verificar a cuál clase pertenece un valor de un tipo producto,
con el predicado \textbf{is}, y la de extraer los sub-valores de un tipo suma
con la instrucción \textbf{match}. El primero se puede usar, siguiendo con el
ejemplo motivador, dentro de un condicional como en el ejemplo \ref{ifis},
mientras que el segundo, como se muestra en el ejemplo \ref{matching}, se puede
usar una vez se tiene certeza de que el valor es de una clase en particular.

\begin{alignat}{3}
&\boldsymbol{if}\ && v\ \boldsymbol{is}\ Leaf && \rightarrow write("leaf") \nonumber \\
&\boldsymbol{[]}\ && v\ \boldsymbol{is}\ Node && \rightarrow write("node") \label{ifis} \\
&\boldsymbol{fi} \nonumber
\end{alignat}

\begin{alignat}{4}
&\boldsymbol{if}\ && v\ \boldsymbol{is}\ Leaf && \rightarrow &&\ var\ elem : int                   \nonumber \\
&                 &&                          &&           ; &&\ v\ \boldsymbol{match}\ Leaf(elem) \nonumber \\
&                 &&                          &&           ; &&\ write (elem)                      \label{matching} \\
&\boldsymbol{[]}\ && \ldots                                                                        \nonumber \\
&\boldsymbol{fi}                                                                                   \nonumber
\end{alignat}

Adicionalmente, es común definir la instrucción \textbf{matches} \todo{ravelo}
como la aplicación secuenciada del predicado \textbf{is} y la instrucción
\textbf{match} de la clase apropiada. El ejemplo \ref{matches} muestra esto,
como una combinación de los ejemplos anteriores, pero sin la necesidad de
declarar explícitamente las variables para los sub-valores.

\begin{alignat}{3}
&\boldsymbol{if}\ && v\ \boldsymbol{matches}\ Leaf(elem)         && \rightarrow write(elem) \nonumber \\
&\boldsymbol{[]}\ && \ldots                                                        \label{matches} \\
&\boldsymbol{fi} \nonumber
\end{alignat}

% \todo{http://foldoc.org/algebraic%20data%20type}
% \todo{\verb{http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf}}

\section{Lógica de Separación}

La Lógica de Separación fue desarrollada por John Reynolds, Hongseok Yang y
Samin Ishtiaq \cite{seplogpaper1}\cite{seplogpaper2}\cite{seplogpaper3} como una
extensión de la lógica de Hoare que permite razonar sobre el acceso a datos en
la memoria de una computadora y como estos pueden mutar. Tal como lo explica
Peter O'Hearn en ~\cite{separation-logic}, la Lógica de Separación se basa en
la \textit{conjunción separadora} $P * Q$, que significa que P y Q apuntan a
porciones de memorias disjuntas. De esta forma se pueden escribir predicados
que permitan realizar verificaciones sobre estructuras que hacen uso de
apuntadores, como por ejemplo verificar que una estructura es un árbol
binario.

\begin{align}
  tree(E) \Longleftrightarrow\ &\boldsymbol{if}\ isatom?(E)\ \boldsymbol{then}\ emp \label{eq:treesl}\\
             &\boldsymbol{else}\ \exists xy.\ E\mapsto[l:\ x,\ r:\ y]\ ∗\ tree(x)\ ∗\ tree(y) \nonumber
\end{align}

Un árbol binario se caracteriza por el hecho de que cada nodo debe estar en un
espacio de memoria distinto a los demás, lo que asegura que no existan ciclos.
En el ejemplo \ref{eq:treesl}, asumiendo que el predicado \textbf{isatom?} puede realizar
la distinción entre si es un valor atómico (entero, caracter, ...) o una
referencia a memoria, se procede a verificar si la estructura E es un átomo.
En caso positivo se devuelve el valor \textbf{emp}, el cual representa al heap
vacío, es decir, el heap en donde no existen celdas reservadas. Si por el
contrario E no es un átomo, entonces se verifica para cada hijo que sea un
árbol binario, cubriendo así el caso recursivo. El operador \todo{nombre?}
$E\mapsto x$ significa que E apunta al fragmento de memoria x. En este caso se
hace uso de este operador de la forma $E\mapsto [l: x, r: y]$ que significa que
los hijos izquierdo y derecho se ubican en los fragmentos de memorias $x$ y $y$
respectivamente, y no es mas que una abreviación de $(E\mapsto x) * (E+1\mapsto y)$.

Aunado a esto, la lógica de separación permite hacer pruebas de la forma $s,h
\vDash P$ donde s es un valor almacenado, h es un fragmento de memoria o heap
y P es una aserción que se realizar sobre s y h. También se cuenta con el operador
\textit{implicación separadora} $P-*\ Q$ que se entiende como, si para un heap dado
se cumple P, entonces al extender este primer heap con otro heap disjunto se
debe cumplir Q, y de manera formal, $s,h \vDash P-*\ Q$ se cumple si para todo h'
disjunto de h $s,h' \vDash P$ y $s,h\Union h' \vDash Q$.
