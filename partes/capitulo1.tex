\chapter{Marco Teórico}
\label{capitulo1}
\setchapter{Capítulo 1. \emph{Marco Teórico}}

\section{Semántica Axiomática y tripletas de Hoare}

Según Araujo y Jiménez~\cite{ayj}, citando a Nipkow y Klein~\cite{concrete}, una
semántica formal de un lenguaje de programación es un modelo matemático que
permite comprender y razonar formalmente sobre el comportamiento de los
programas escritos en él. Se dice que una Semántica es una \textbf{Semántica
Axiomática} cuando las propiedades de las  distintas construcciones del lenguaje
son expresadas mediante proposiciones lógicas. La \textbf{Lógica de Hoare} es un
sistema formal de proposiciones lógicas utilizado para describir  las
propiedades de una Semántica Axiomática, permitiendo demostrar la corrección
parcial de programas. Las fórmulas en la Lógica de Hoare son llamadas
\textbf{Tripletas de Hoare} y se escriben de la siguiente manera:

\begin{equation*}
\begin{gathered}
\{P\}\ S\ \{Q\}
\end{gathered}
\end{equation*}


En la tripleta anterior, $S$ es una instrucción, mientras que $P$ y $Q$ son
llamadas \textbf{Precondición} y \textbf{Postcondición}, respectivamente. El
significado de esta tripleta es el siguiente: si la precondición $P$ sobre el
estado de las variables del programa es cierta inmediatamente antes de la
ejecución de $S$, y $S$ culmina su ejecución, entonces la postcondición $Q$ sobre
el estado de las variables del programa es cierta al finalizar $S$. Con esta
aproximación, es posible demostrar la corrección parcial de los programas, ya
que la postcondición sólo se cumple cuando el programa termina; mientras que para
demostrar la corrección total de un programa, es necesario garantizar que si la
precondición se cumple, el programa termina.

\section{Teoría de conjuntos}

La Teoría de Conjuntos~\cite{gries} es la rama de la matemática que se encarga
del estudio de colecciones bien formadas de objetos, que pueden o no ser de
naturaleza matemática. Esta teoría surge de la idea original de conjuntos de
Georg Cantor, quien los definió como una colección, finita o infinita, de
objetos definidos y distinguibles, y a su vez los conjuntos pueden ser
considerados en sí mismos como objetos.

A partir de las ideas de Cantor, se comenzó un proceso de axiomatización de la
matemática, con el cual se construyeron en base a los conjuntos otros objetos
matemáticos como los números, las funciones y otras estructuras. De la teoría de
conjuntos podemos destacar las siguientes estructuras:

\begin{description}[leftmargin=!,labelwidth=\widthof{\bfseries Multiconjunto}]

  \item [Conjunto] Los conjuntos son colecciones tales que todos sus elementos
  debes ser distintos entre sí. Cuenta con operadores binarios como la unión, la
  intersección y la resta entre conjuntos, así como el operador complemento, con
  el que se obtiene un nuevo conjunto que contiene todos los elementos, con
  respecto a un universo, que el conjunto original no poseía.

  \item [Multiconjunto] Los multiconjuntos son colecciones en las que cada
  elemento tiene una multiplicidad asociada, es decir, puede contener dos o mas
  elementos que sean idénticos entre sí. Cuenta con los operadores  binarios de
  unión, intersección y resta de multiconjuntos, así como con la suma de
  multiconjuntos.

  \item [Secuencia] Las secuencias son colecciones de objetos enumerados, en las
  cuales se permite la repetición de los mismos. A diferencia del conjunto y el
  multiconjunto, el orden de los elementos sí tiene importancia. Formalmente,
  una secuencia puede ser definida como una función cuyo dominio es un 
  subconjunto de los números naturales de la forma $[0, n)$, donde $n$ es el 
  tamaño de la secuencia, y cuyo codominio es un subconjunto del tipo que 
  corresponde a los elementos. Cuenta con los operadores de concatenación y
  subindización.

  \item [Relación] Una relación es una asociación entre un conjunto de entrada
  (dominio) y un conjunto de salida (codominio). Formalmente se modelan como
  conjuntos de pares, donde el primer elemento de cada par pertenece al dominio
  y el segundo al codominio.

  \item [Función] Las funciones son relaciones con la restricción de que cada
  elemento del dominio se corresponde con un único elemento del codominio,
  construyendo así un mecanismo que permite transformar cualquier elemento del
  dominio a uno del codominio. De igual forma, las funciones pueden modelarse
  formalmente como un conjunto de pares, donde el primer elemento del par
  pertenece al dominio y el segundo al codominio, pero asegurando que no
  pertenezcan al conjunto dos pares cuyo primer elemento sea igual.

\end{description}

\section{Tipos de dato abstractos} \label{tda1}

Cuando se programa en un lenguaje de alto nivel, se espera poder abstraer el
problema que se intenta resolver, de forma que se puedan expresar solos los
detalles relevantes, como los posibles uso de un programa, y suprimir aquellos
detalles que no lo son, como la implementación del programa.

Un Tipo de Dato Abstracto o TDA define una clase de objetos abstractos, los
cuales se caracterizan completamente por las operaciones disponibles que pueden
aplicarse a estos~\cite{liskov}. En otras palabras, un TDA puede ser
especificado a través de operaciones características del tipo en cuestión y un
conjunto de valores a los cuales se le aplican dichas operaciones, que definen
su comportamiento lógico~\cite{dalewalker}. De esta forma se desliga la
especificación formal de la implementación concreta de un tipo, pudiendo
discriminar entre una implementación u otra, sin afectar su comportamiento.

Comúnmente, la especificación formal de un TDA posee un modelo abstracto de
representación, que consiste en una colección de estructuras internas de alto
nivel como conjuntos o relaciones, y sus operaciones se modelan como
procedimientos y funciones, de los cuales solo se necesitan saber las
precondiciones, postcondiciones e invariantes que deben cumplirse, expresadas
en lenguaje natural o en lenguaje matemático.

Una vez que se dispone de un TDA que modele de manera adecuada el
comportamiento de un tipo de dato de interés, se procede a implementarlo. Para
esto se debe escoger un nuevo modelo de representación que solo haga uso de
estructuras concretas y re-especificar la aserciones encontradas en el TDA, en
términos de este nuevo modelo. Adicionalmente, se debe garantizar la
consistencia entre el modelos abstracto de representación y el modelo de
representación de la implementación haciendo uso de técnicas de refinamiento,
especificando formalmente la correspondencia entre ambos modelos. Finalmente
se implementan todos los procedimientos y funciones correspondientes a las
operaciones del TDA~\cite{ravelo}.

\begin{alignat}{1}
  \{ P[X,Y:=A,&B]\, \land \, Invs(A \cup B)\} \nonumber \\
  p\  (A,&B,C) \label{eqn:tdatriple} \\ 
  \{ Q[X,Y,Z:=A_0,&B,C]\, \land \, Invs(B \cup C)\} \nonumber
\end{alignat}

Una propiedad importante de los TDAs es que sus procedimientos jamás deben
alterar sus invariantes, pues de lo contrario, el objeto afectado por el
procedimiento ya no pertenecería al modelo abstracto. Esta propiedad puede
representarse como una familia de tripletas de Hoare (figura
\ref{eqn:tdatriple}), donde $p$ es un procedimiento definido como
$\textbf{proc}\ p (in\ X : \textrm{TX}, in\textrm{-}out\ Y : \textrm{TY}, out\ Z : \textrm{TZ})$, $P$ y $Q$ son, respectivamente, la precondición y postcondición de este procedimiento, $X$, $Y$ y $Z$ son listas de parámetros formales que posiblemente incluyen
variables de Tipos de Dato Abstractos, $A$, $B$ y $C$ son listas de parámetros reales pasados al procedimiento $p$ tal que todos sus tipos corresponden a los de $X$, $Y$ y $Z$ respectivamente, $A_0$ es la lista con los valores iniciales de los valores
en $A$, e $Invs(X)$ es equivalente a la expresión $(\forall x\ |\ x \in X : Inv(x) )$, donde $Inv(x)$ es el predicado que condensa todos los
invariantes del valor $x$ si $x$ es de un TDA. La derivación de esta tripleta de Hoare se muestra en el apéndice \ref{derivhoare}.

\section{Tipos Algebraicos Libres}

En la teoría de tipos, un tipo algebraico libre~\cite{ravelotal, foldoc,
lazywithclass} es una forma particular de tipo compuesto que permite definir
tipos producto y tipos suma, además de tipos que son una combinación de ambos.
Los valores de un tipo producto suelen contener varios sub-valores de distintos
tipos, y el conjunto de valores posibles es el producto cartesiano de los
conjuntos de cada sub-tipo, de ahí la denominación de tipo <<producto>>. Por
otro lado, los tipos suma definen varias \textit{clases} tales que  los valores
de un tipo suma sólo pueden pertenecer a una clase a la vez, de modo que el
conjunto de valores posibles para un tipo suma es la unión de los valores
posibles para cada clase, notando que la cardinalidad de este conjunto será la
suma de los conjuntos de las clases, debido a que son disjuntos.

El ejemplo motivador en la mayoría de los cursos que hablan sobre Tipos
Algebraicos Libres (TALs) es el del árbol binario. Un lenguaje que soporte TALs
aceptaría una definición como la de la figura \ref{eqn:freetype}.

\begin{alignat}{1}
\textbf{freetype}\ Tree(e)\ = Leaf(e)\ |\ Node(Tree(e),\ Tree(e)) \label{eqn:freetype}
\end{alignat}


Este TAL es el tipo suma suma de las clases
$Leaf(e)$ y $Node(Tree(e),\ Tree(e))$,
y esta última es, a su vez, un tipo producto de $(Tree(e))$ y $(Tree(e))$.

Otra característica importante de los TALs, que los hace muy útiles, es la
posibilidad de verificar a cuál clase pertenece un valor de un tipo producto,
con el predicado \textbf{is}, y la de extraer los sub-valores de un tipo suma
con la instrucción \textbf{match}. El primero se puede usar, siguiendo con el
ejemplo motivador, dentro de un condicional como en el ejemplo~\ref{ifis},
mientras que el segundo, como se muestra en el ejemplo~\ref{matching}, se puede
usar una vez se tiene certeza de que el valor es de una clase en particular.

\begin{alignat}{3}
&\boldsymbol{if}\ && v\ \boldsymbol{is}\ Leaf && \rightarrow write("leaf") \nonumber \\
&\boldsymbol{[]}\ && v\ \boldsymbol{is}\ Node && \rightarrow write("node") \label{ifis} \\
&\boldsymbol{fi} \nonumber
\end{alignat}

\begin{alignat}{4}
&\boldsymbol{if}\ && v\ \boldsymbol{is}\ Leaf && \rightarrow &&\ var\ elem : int                   \nonumber \\
&                 &&                          &&           ; &&\ v\ \boldsymbol{match}\ Leaf(elem) \nonumber \\
&                 &&                          &&           ; &&\ write (elem)                      \label{matching} \\
&\boldsymbol{[]}\ && \ldots                                                                        \nonumber \\
&\boldsymbol{fi}                                                                                   \nonumber
\end{alignat}

Adicionalmente, es común definir la instrucción \textbf{matches}~\cite{ravelo}
como la aplicación secuenciada del predicado \textbf{is} y la instrucción
\textbf{match} de la clase apropiada. El ejemplo~\ref{matches} muestra esto,
como una combinación de los ejemplos anteriores, pero sin la necesidad de
declarar explícitamente las variables para los sub-valores.

\begin{alignat}{3}
&\boldsymbol{if}\ && v\ \boldsymbol{matches}\ Leaf(elem)         && \rightarrow write(elem) \nonumber \\
&\boldsymbol{[]}\ && \ldots                                                        \label{matches} \\
&\boldsymbol{fi} \nonumber
\end{alignat}

\section{Lógica de Separación}

La Lógica de Separación fue desarrollada por John Reynolds, Hongseok Yang y
Samin Ishtiaq~\cite{seplogpaper1,seplogpaper2,seplogpaper3} como una
extensión de la lógica de Hoare que permite razonar sobre el acceso a datos en
la memoria de una computadora y como estos pueden mutar. Tal como lo explica
Peter O'Hearn en~\cite{separation-logic}, la Lógica de Separación se basa en
la \textit{conjunción separadora}, $P\, \ast\, Q$, que significa que P y Q apuntan a
porciones de memorias disjuntas. De esta forma se pueden escribir predicados
que permitan realizar verificaciones sobre estructuras que hacen uso de
apuntadores, como por ejemplo verificar que una estructura es un árbol
binario.

\begin{align}
  tree(E) \Longleftrightarrow\ &\boldsymbol{if}\ isatom?(E)\ \boldsymbol{then}\ emp \label{eq:treesl}\\
             &\boldsymbol{else}\ \exists xy.\ E\mapsto[l:\ x,\ r:\ y]\ *\ tree(x)\ *\ tree(y) \nonumber
\end{align}

Un árbol binario se caracteriza por el hecho de que cada nodo debe estar en un
espacio de memoria distinto a los demás, lo que asegura que no existan ciclos.
En el ejemplo~\ref{eq:treesl}, asumiendo que el predicado \textbf{isatom?} puede
realizar la distinción entre si es un valor atómico (entero, carácter, ...) o
una referencia a memoria, se procede a verificar si la estructura E es un átomo.
En caso positivo se devuelve el valor \textbf{emp}, el cual representa al
\textit{heap} vacío, es decir, el \textit{heap} en donde no existen celdas
reservadas. Si por el contrario E no es un átomo, entonces se verifica para cada
hijo que sea un árbol binario, cubriendo así el caso recursivo. El operador
deconstrucción de \textit{heap} unitario, $E \mapsto x$, significa que E apunta al
fragmento de memoria $x$. En este caso se hace uso de este operador de la forma
$E\mapsto [l: x, r: y]$ que significa que los hijos izquierdo y derecho se
ubican en los fragmentos de memorias $x$ y $y$ respectivamente, y no es mas que
una abreviación de $(E\mapsto x) * (E+1\mapsto y)$.

La lógica de separación permite hacer pruebas de la forma $s,h
\vDash P$ donde s es un valor almacenado, $h$ es un fragmento de memoria o
\textit{heap} y $P$ es una aserción que se realiza sobre $s$ y $h$. También cuenta
con el operador \textit{implicación separadora}, $P-*\ Q$, que se entiende como, si
para un \textit{heap} dado se cumple $P$, entonces al extender este primer
\textit{heap} con otro \textit{heap} disjunto se debe cumplir $Q$; de manera
formal, $s, h \vDash P-*\ Q$ se cumple si $\forall h', h' \cap h = \emptyset, h' \vDash
P\,\, \land \,\, s, h \cup h' \vDash Q$.
