\chapter{Marco Tecnológico}
\label{capitulo2}
\lhead{Capítulo 2. \emph{Marco Tecnológico}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% LENGUAJES DE PROGRAMACIÓN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Lenguajes de Programación}

Para la implementación de los distintos componentes del presente proyecto de
grado, se utilizaron los lenguajes Haskell, C y C++. El primero se usó para
escribir las distintas fases del compilador, mientras que los otros dos se
utilizaron para desarrollar las bibliotecas externas para los programas
compilados.

\subsection{Haskell}
Haskell es un lenguaje de programación funcional puro compilado, de proposito
general, que se basa en el \textit{cálculo lambda}. Al ser un lenguaje
funcional puro, todo programa se escribe haciendo uso de expresiones
matemáticas puras y se asegura que para todo valor que se proporcione como
entrada, las funciones llamadas dentro de la ejecución del mismo, devolveran
siempre el mismo resultado. Esto se debe a la carencia de variables mutables y
efectos de borde, lo que permite a su vez, generar código ensamblador mas
astuto con respecto a los lenguajes imperativos.

Entre sus principales caracteristicas está la de un sistema de tipos estático
y fuertemente tipado, es decir, para todas las estructuras declaradas en el
programa, se verifica su tipo a tiempo de compilación y toda conversión entre
tipo debe colocarse de manera explícita. Por otro lado, La evaluación de
expresiones es de forma perezosa, dando como consecuencia que ninguna
expresión se evalue hasta el momento en el que se usa y la posibilidad de
poder crear estructuras infinitas, las cuales son construidas parcialmente
mientras van siendo utilizadas.

Escribir un programa haciendo uso exclusivamente de expresiones matemáticas
puras, trae consigo limitaciones cuando se requiere realizar operaciones de
entrada y salida, o cualquier otra operación que implique efectos de bordes.
Este tipo de cómputo se puede lograr dentro de un lenguaje funcional haciendo
uso de los \textit{monads}, estructuras que permiten representar cálculos una
como secuencia de operaciones y que proporcionan contexto a las expresiones
puras. Estos contextos monádicos permiten realizar computos de entrada y
salida, manejo de excepciones, entre otros, sin dejar de lado la pureza
funcional.

Uno de los factores que se debe tomar en cuenta cuando se elige un lenguaje de
programación, es la cantidad y calidad de las bibliotecas disponibles para el
mismo. Haskell, posee una amplia gama de bibliotecas de mucha utilidad, entre la
cuales destacan las bibliotecas que permiten depurar y perfilar programas,
manejar y reresentar estructuras complejas, y en el caso del presente
proyecto, bibliotecas que proporcionan facilidades para construir reconocedores
recursivos descendentes y para generación de código intermedio LLVM, las
cuales seran menciadas en detalles en las siguientes secciones.


\subsection{C, C++}
\textit{C} y \textit{C++} son lenguajes imperativos, y orientado a objetos en
el caso de \textit{C++}. Estos dos lenguajes poseen un sistema de tipo
estáticos y debilmente tipificados, pero ofrecen ventajas para realizar
operaciones a muy bajo nivel, como el manejo y acceso manual de la memoria.

Ambos lenguajes poseen mecanismo para declarar estructuras de datos basicos,
funciones y tipos enumerados, sin embargo, con \textit{C++}, al ser un
lenguaje orientado a objetos, entran conceptos como cleses, herencia de clases
y encapsulamiento. Tambien, a diferencia del lenguaje \textit{C}, \textit{C++}
posee una biblioteca estandar mas extensa, en la cual se ofrecen estructuras
de datos mas complejas como mapas, conjuntos o vectores, y algoritmos
ordenamiento o busqueda sobre dichas estructuras.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% HERRAMIENTAS PARA ANÁLISIS LÉXICO Y SINTÁCTICO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Herramientas para Análisis Léxico y Sintáctico}

\subsection{Parsec}
\textit{Parsec} es una biblioteca destinada a facilitar herramientas para la
construcción de un reconocedor recursivo descendente. Esta biblioteca provee
de una estructuras monádica, con las que se pueden generar reconocedores
sintácticos básicos y combinarlos para formar reconocedores cada vez más
complejos. Debido a la naturaleza monádica de los computos que se realizan, se
puede hacer uso de funciones y operadores, como por ejemplo, \texttt{many} o
\texttt{<|>}, los cuales permiten ejecutar cero o mas veces un reconocedor, o
ejercutar un segundo reconocedor en caso de que el primero falle,
respectivamente.

Si bien no se ofrece soporte para recuperación de errores, se puede
implementar haciendo uso la función \texttt{try}, la cual reestablece el
estado original del flujo de entrada, en caso de que un reconocedor falle,
habiendo o no consumido de la entrada.

\subsection{Megaparsec}
La biblioteca \textit{Megaparsec} es un bifurcación (\emph{fork}, en inglés)
de la biblioteca \textit{Parsec}, la cual ademas de ofrecer la mismas
funcionalidades que ésta ultima, agrega otras funcionalidades de especial
importancia para la elaboración de un analizador sintáctico, como el soporte
para la recuperación de errores.

\todo{extender esto}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% HERRAMIENTAS PARA LA GENERACIÓN DE CÓDIGO INTERMEDIO %%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Herramientas para la Generación de Código Intermedio}

\subsection{LLVM}

\subsection{llvm-general y llvm-general-pure}

Las bibliotecas \texttt{llvm-general} y \texttt{llvm-general-pure} para el
lenguaje Haskell ofrecen una interfaz muy sencilla y completa con las
bibliotecas externas de LLVM para la generación de código intermedio. Por un
lado, \textit{llvm-general-pure} brinda una serie de estructuras de datos que se
corresponden con las definiciones, instrucciones y expresiones del código
intermedio de LLVM. A su vez, \textit{llvm-general} da las facilidades para
poder traducir, haciendo uso de las estructuras encontradas en
\textit{llvm-general-pure}, el árbol sintáctico generado por el analizador
sintáctico, a un nuevo árbol sintáctico a partir del cual posteriormente se
genera automáticamente un archivo con la representación intermedia de LLVM del
programa.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% HERRAMIENTAS PARA LA DEPURACIÓN DEL MANEJO DE MEMORIA %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Herramientas para la Depuración del Manejo de Memoria}

Para este fin se utilizó \textit{Valgrind}. \textit{Valgrind} es una herramienta
de software, que ayuda a la depuraración y detección errores relacionados a una
mala gestión de la memoria de un proceso, como accesos indebidos o la fuga de
memoria dinámica. Tambien permite realizar un perfilaje detallado de la
ejecución de un programa y detectar errores en procesos multihilo.

En este proyecto, se utilizó \textit{Valgrind} con la intención de detectar
posibles fugas de memoria en el código de las librerías externas de Graciela,
particularmente en el caso de las estructuras de tipos de la teoría de
conjuntos, y en el código generado para las nuevas instrucciones \ingra{new} y
\ingra{free} de apuntadores. Adicionalmente, se usó para revisar los accesos a
memoria relacionados con los arreglos, debido a la forma en la que fueron
implementados.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% AMBIENTES DE PROGRAMACIÓN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Ambientes de programación}

Como objetivo adicional \todo{ask novich}, se estudió la posibilidad de
incorporar herramientas para mejorar la experiencia del programador en Graciela.
Específicamente, se indagó acerca de los editores de texto para programación más
comúnmente usados entre los estudiantes de la carrera de Ingeniería de la
Computación y sobre cómo agregarles características como un resaltador
sintáctico y la inserción automática de fragmentos de código.

\begin{enumerate}[label=\emph{}]
	\litem{Vi} Es un editor de texto presente en todos los sistemas operativos derivados de
	Unix, que  permite mover, copiar, eliminar o insertar caracteres con mucha
	versatilidad. Cuenta con una versión mejorada llamada \textit{Vim}. Tiene como
	ventaja su simplicidad y contar con una importante cantidad de paquetes que
	permiten personalizar a gusto del usuario el editor.
	
	\litem{Sublime Text} Editor de texto escrito en el lenguaje C++ y con soporte 
	para \textit{plug-ins} escritos en el lenguaje Python.
	
	\litem{Atom} Atom es un editor de texto escrito en el lenguaje JavaScript. El editor puede
	personalizarse a gusto del usuario pero tiene la desventaja de ser mas lento
	en comparación con otros editores compilados como Vi o Sublime Text

 \litem{Gedit} Editor de texto que viene por defecto con el entorno de escritorio GNOME y fue
\end{enumerate}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% DISTRIBUCIÓN DE SOFTWARE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Distribución de software}

Para facilitar la distribución e instalación de los componentes de Graciela, se
estudiaron los mecanismos de distribución de software más comunes para las
plataformas en las cuales se ofrece el compilador, con la intención de que sea
sencillo agregar el compilador a sus sistemas, y mantenerlo actualizado con la
última versión disponible.

\subsection{APT}

\subsection{Homebrew}

Manejador de paquetes para el sistema operativo macOS. Entre las razones por
la cual se eligió este manejador de paquetes, fue su simplicidad de uso, tanto
para quien desea instalar una pieza de software, como para quien crea y
distribuye el paquete, comparación de las demás opciones disponibles.
