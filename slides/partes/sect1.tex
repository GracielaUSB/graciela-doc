\section{Análisis del trabajo previo}

\subsection*{Recomendaciones}
\begin{frame}{Recomendaciones de Araujo y Jiménez}
\begin{itemize}
  \item Ofrecer Tipos de Dato Abstractos
  \item Permitir la manipulación de apuntadores.
  \item Proveer tipos de dato enumerados.
\end{itemize}
\end{frame}

\subsection*{Mejoras}

\defverbatim[colored]\limits{
\begin{lstlisting}[language=graciela, style=code, escapechar=\~]
var arr : array [5] of int;
write(arr[6]); // Esta línea fallará a tiempo de ejecución
\end{lstlisting}
}

\defverbatim[colored]\multidim{
\begin{lstlisting}[language=graciela, style=code, escapechar=\~]
`var arr : array [5] of array [6] of int;`
`write(arr[3][4]);`
var arr : array [5, 6] of int;
write(arr[3, 4]);
\end{lstlisting}
}

\defverbatim[colored]\inoutarr{
\begin{lstlisting}[language=graciela, style=code, escapechar=\~]
proc p (in a : array [5] of int, out b : array [1~~0] of float)
\end{lstlisting}
}

\begin{frame}{Arreglos}
\framesubtitle{Arreglados}
\begin{itemize}
  \item Se sustituyeron los arreglos de arreglos por arreglos multidimensionales. \multidim{}

  \item Los arreglos ahora pueden ser pasados como parámetros de modo In, In-Out y Out a procedimientos, además del modo Ref. \inoutarr{}

\end{itemize}
\end{frame}
\begin{frame}{Arreglos}
\framesubtitle{Arreglados, cont.}
\begin{itemize}

  \item Se agregó verificación de límites de arreglos. \limits{} Esto exigió un
  cambio en su estructura interna para almacenar su tamaño antes de sus elementos, en una especie de arreglos conformantes.

  GRAFIQUITO

\end{itemize}
\end{frame}

\defverbatim[colored]\boundproc{
\begin{lstlisting}[language=graciela, style=code, escapechar=\~]
proc p (...)
{pre   ...   pre}
{post  ...  post}
{bound ... bound}
|[ ... p() ... ]|
\end{lstlisting}
}

\defverbatim[colored]\cnfquant{
\begin{lstlisting}[language=graciela, style=code, escapechar=\~]
(% ~\qop~ i : int | 0 < i /\ i < 100 /\ (p(i) \/ q(i)) | ... %)
(% ~\qop~ x : float | x ~\Elem~ xs | ... %)
\end{lstlisting}
}

\defverbatim[colored]\countquant{
\begin{lstlisting}[language=graciela, style=code, escapechar=\~]
(% # i : T | ... | ... %)
\end{lstlisting}
}

\defverbatim[colored]\constmode{
\begin{lstlisting}[language=graciela, style=code, escapechar=\~]
proc f (const c : int, out r : int) 
    ...
\end{lstlisting}
}

\begin{frame}{Otros cambios}
\begin{itemize}
  \item Los procedimientos y funciones recursivos ahora exigen la definición de una expresión de cota. \boundproc{}

  \item Las cuantificaciones admiten rangos más generales en forma normal conjuntiva. \cnfquant{}
\end{itemize}
\end{frame}

\begin{frame}{Otros cambios}
\begin{itemize}
  \item Se agregó el operador de cuantificación \texttt{count} de Dijkstra. \countquant{}

  \item Se agregó el modo de parámetros Const, sólo para variables de tipos básicos, que asegura que el parámetro no es modificado dentro del procedimiento. \constmode{}

\end{itemize}
\end{frame}

% \section{Lo superficial}

% \subsection*{Nombres}
% \begin{frame}{Nombres}
% \begin{itemize}
%   \item This is not \textit{gacela}.
%   \item El lenguaje es Graciela.
%   \item El compilador es \texttt{graciela}.
% \end{itemize}
% \end{frame}


% \subsection*{El comando}
% \begin{frame}{El comando}
% \framesubtitle{UX stands for stUdent eXperience}
% \begin{itemize}
%   \item Compilar antes: \begin{itemize}
%     \item\texttt{gacela tarea.gcl 0}
%     \item\texttt{llc-3.5 -filetype=obj tarea.bc}
%     \item\texttt{gcc tarea.o /lib/x86\_64-linux-gnu/auxiliarFunctions.so -o tarea}
%   \end{itemize}
%    \item Compilar ahora: \begin{itemize}
%     \item\texttt{graciela tarea.gcl -o tarea}
%     \item That's it.
%     \item Si el estudiante quiere ver más o menos errores, flag \texttt{-e=n}.
%   \end{itemize}
% \end{itemize}
% \end{frame}


% \subsection*{Instalación}
% \begin{frame}{Instalación}
% \framesubtitle{UX stands for stUdent eXperience}
% \begin{itemize}
%   \item apt-get (Ubuntu): \begin{itemize}
%     \item\texttt{\# add-apt-repository ppa:graciela-usb/ppa}
%     \item\texttt{\# apt-get install graciela}
%   \end{itemize}
%   \item Homebrew (OS X) : \begin{itemize}
%     \item\texttt{\$ brew tap GracielaUSB/graciela}
%     \item\texttt{\$ brew install graciela}
%   \end{itemize}
% \end{itemize}
% \end{frame}


% \subsection*{Add-ons}
% \begin{frame}{Colores!}
% \framesubtitle{UX stands for stUdent eXperience}
% \begin{itemize}
%   \item\visible<1->{Resaltador de sintaxis para Sublime Text},
%   \item\visible<2->{próximamente para otros editores.}

%   \vskip 1cm

%   \item\visible<3->{*breve demostración*}
% \end{itemize}
% \end{frame}


% \defverbatim[colored]\makeset{
% \begin{lstlisting}[language=graciela, style=code, escapechar=\~]
% var x : int;
% \end{lstlisting}
% }

% \begin{frame}{SINTAXIS!}
% \makeset
% \end{frame}


% \subsection*{Fixes}
% \begin{frame}{Fixes}
% \framesubtitle{Look ma, no floats!}
% \begin{itemize}
%   \item\visible<1->{El compilador no muestra (tantos) errores de Haskell}
%   \item\visible<2->{Se mejoró la implementación de la recuperación de errores en el analizador sintáctico}
%   \item\visible<3->{Los flotantes no dan error de compilación}
% \end{itemize}
% \end{frame}


% \subsection*{Pendientes}
% \begin{frame}{Pendientes}
% \framesubtitle{\texttt{Non-exhaustive patterns in function <insert function here>}}
% \begin{itemize}
%   \item Sigue habiendo errores en la generación de código para cuantificadores (rangos),
% \end{itemize}
% \end{frame}